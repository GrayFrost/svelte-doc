## compiler

### parse

解析svelte文件

tag, mustache, text

tag除了原生，还包括svelte:html, svelte:body, svelte:component, svelte:element等等

mustache模板语法

text纯文本

script分为instance和module

script 的解析主要靠的是[code-red](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FRich-Harris%2Fcode-red "https://github.com/Rich-Harris/code-red")，它是基于[acorn](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Facornjs%2Facorn "https://github.com/acornjs/acorn")的封装

### compile

将parse解析得到的语法树转成js文件

语法的最终编译是来自[code-red](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FRich-Harris%2Fcode-red "https://github.com/Rich-Harris/code-red")的 print 将调整后的语法树转换成为代码

第一步将 parse 过程中拿到的语法树（包含 html，css，instance 和 module）转换为 Component，第二步将 Component 进入**render dom**处理并生成 component 的转换代码以及 runtime，第三步输出 compiler 的结果

## runtime

create_fragment

instance

脏检测 make_dirty

[官方Example](https://svelte.dev/examples/hello-world#hello-world)

```html
<script>
	let name = 'world';
</script>

<h1>Hello {name}!</h1>
```

```javascript
/* App.svelte generated by Svelte v4.2.8 */
import {
	SvelteComponent,
	detach,
	element,
	init,
	insert,
	noop,
	safe_not_equal
} from "svelte/internal";

import "svelte/internal/disclose-version";

function create_fragment(ctx) {
	let h1;

	return {
		c() {
			h1 = element("h1");
			h1.textContent = `Hello ${name}!`;
		},
		m(target, anchor) {
			insert(target, h1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(h1);
			}
		}
	};
}

let name = 'world';

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment, safe_not_equal, {});
	}
}

export default App;
```

```javascript
interface Fragment {
  key: string | null;
  first: null;
  /* create  */ c: () => void;
  /* claim   */ l: (nodes: any) => void;
  /* hydrate */ h: () => void;
  /* mount   */ m: (target: HTMLElement, anchor: any) => void;
  /* update  */ p: (ctx: any, dirty: any) => void;
  /* measure */ r: () => void;
  /* fix     */ f: () => void;
  /* animate */ a: () => void;
  /* intro   */ i: (local: any) => void;
  /* outro   */ o: (local: any) => void;
  /* destroy */ d: (detaching: 0 | 1) => void;
}

```

编译出来的结果就是有一个初始化函数，叫 create_fragment，它是用于 dom 的初始挂载。create_fragment 的过程还包含有 `c,m,p,i,o,d`等特殊名称的函数，这些函数并非编译混淆，而是 Fragment 内部的生命周期缩写


SvelteComponent 则是包含了 svelte 组件内置的属性和生命周期，它们与 Fragment 的属性和生命周期是息息相关，SvelteComponent 是依赖于 Fragment，组件的变化会触发 Fragment 的变化


svelte 官方的 webpack 插件[svelte-loader](https://github.com/sveltejs/svelte-loader)和 rollup 插件[rollup-plugin-svelte](https://github.com/sveltejs/rollup-plugin-svelte)的主要都是基于 svelte.compile，这个编译器主要分为两部分 parse 和 compile，parse 是解析的过程，解析 script 和 style 等 tag 标签以及 each 和 ifelse 等 mustache 模版语法。compile 则是包含了 parse 的动作，将解析出来的 ast 语法树转换为可执行的代码
