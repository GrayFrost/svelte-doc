好看的动画往往能给页面带来锦上添花的效果，不仅能提升用户体验，还能增强页面美观度。流畅丝滑的动效背后，除了开发时的灵感迸发，也需要强有力的数学知识的支持。Svelte中集成了多个服务于动画效果的方法：
* svelte/motion
* svelte/easing
* svelte/transition
* svelte/animation

## Motion

Motion指运动效果，svelte/motion导出了两个方法tweened和spring。使用这两个方法得到的值是一个可写状态的store。
  
### Tweened

Tweened即补间动画。补间（动画）（来自 [in-between](https://en.wikipedia.org/wiki/Inbetweening)）是一个概念，允许用户以平滑的方式更改对象的属性。我们只需告诉它哪些属性要更改，当补间结束运行时它们应该具有哪些最终值，以及这需要多长时间，补间引擎将负责计算从起始点到结束点的值。补间动画的状态会在固定的时间间隔内不断更新其值。

比如在我们设置css时，我们设置了元素的起点和终点，而至于过程是怎么运动的，则由电脑来决定。
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .box {
        width: 100px;
        height: 100px;
        border: 1px solid orange;
        transition: all 1s ease-in-out;
      }

      .move {
        transform: translate(100px, 100px);
      }
    </style>
  </head>
  <body>
    <button>move</button>
    <div class="box"></div>
    
    <script>
      let button = document.querySelector('button');
      let boxRef = document.querySelector(".box");
      
      button.addEventListener('click', onMove);

      function onMove() {
        if (boxRef) {
          boxRef.classList.add("move");
        } 
      };
    </script>
  </body>
</html>
```

![[test59.gif]]
我们只设置了开头和结尾的位置，以及开头运动到结尾需要1s，期间的运动过程则交由底层处理。这种设置方式不管是在设置ppt动画，制作视频剪辑中都非常常见。

笔者先演示一个不带动画的例子：
```html
<script>
  import { writable } from "svelte/store";

  const progress = writable(0);
</script>

<progress value={$progress}></progress>

{#each [0, 0.25, 0.5, 0.75, 1] as p}
  <button on:click={() => ($progress = p)}>
    {p * 100}%
  </button>
{/each}

<style>
  progress {
    display: block;
    width: 100%;
  }
</style>
```

![[test72.gif]]

当我们使用了补间动画后：
```html
<script>
  import { tweened } from "svelte/motion";
  import { cubicOut } from 'svelte/easing';

	const progress = tweened(0, {
		duration: 300,
		easing: cubicOut
	});
</script>

<progress value={$progress}></progress>

{#each [0, 0.25, 0.5, 0.75, 1] as p}
  <button on:click={() => ($progress = p)}>
    {p * 100}%
  </button>
{/each}

<style>
  progress {
    display: block;
    width: 100%;
  }
</style>
```
因为返回值是一个store，我们可以像正常使用store一样使用`$store`。

![[test73.gif]]

看下tweened的接收参数：
```javascript
function tweened<T>(
	value?: T | undefined,
	defaults?: TweenedOptions<T> | undefined
): Tweened<T>;
```
第一个参数接收一个初始值，第二个参数稍微复杂，是一个对象，能够接收以下参数：
* delay：补间延迟多少毫秒之后开始
* duration：补间效果的持续时间（以毫秒为单位）
* easing：在下一节中详细讲解
* interpolate：一个自定义的 (starting, target) => t => value 函数，用于在任意值之间进行插值。starting是起始值，target是目标值，t是0到1的数值，value是返回结果。

#### interpolate

interpolate是“插值”的意思，默认情况下，Svelte 将在数字、日期以及形状相同的数组和对象之间进行插值（只要它们仅包含数字和日期或其他有效的数组和对象）。如果我们想要插值（例如）颜色字符串或变换矩阵，需要我们自己提供自定义插值器。

比如，我们将数组进行转换：
```html
<script>
  import { tweened } from "svelte/motion";
  import { cubicOut } from 'svelte/easing';

	const arr = tweened([1, 2, 3, 4, 5], {
		duration: 500,
		easing: cubicOut
	});
</script>

<button on:click={() => $arr = [6, 7, 8, 9, 10]}>change</button>

{#each $arr as item}
  <div>{item}</div>
{/each}
```
  
![[test74.gif]]
这里的gif图由于帧率问题，只看出了几次变化，然而我们真实的页面改动频率则高得多。

再比如，如果我们需要进行颜色改变的补间动画，会使用到[d3-interpolate](https://d3js.org/d3-interpolate)：
```html
<script>
  import { tweened } from "svelte/motion";
  import { cubicInOut } from 'svelte/easing';
  import { interpolate } from "d3-interpolate";

  let colors = ['red', 'blue', 'green', 'pink'];
  let color = tweened('red', {
    duration: 1000,
    easing: cubicInOut,
    interpolate: interpolate,
  });

  const changeColor = (c) => {
    $color = c;
  }
</script>

{#each colors as color}
  <button on:click={() => changeColor(color)}>{color}</button>  
{/each}
<h2 style="color: {$color}">{$color}</h2>
```

![[test75.gif]]

interpolate的要求必须是`(a, b) => t => value`格式的函数，我们简单看下各参数的意义：
```html
<script>
  import { tweened } from "svelte/motion";
  import { cubicOut } from 'svelte/easing';

	const value = tweened(0, {
		duration: 500,
		easing: cubicOut,
    interpolate: (a, b) => {
      console.log('a,b', a, b)
      return (t) => {
        console.log('t', t);
        return t;
      }
    }
	});
</script>

<button on:click={() => $value = 100}>change</button>
<h1>{$value}</h1>
```
![[test16.gif]]
从打印的结果中，我们可以推断出，a是初始值，b是下一次更改的值，t是百分率，关键就在于t。
通过t的变化，我们可以丝滑地改动我们的变化值，当最终值无法超过b。

```diff
<script>
  import { tweened } from "svelte/motion";
  import { cubicOut } from 'svelte/easing';

	const value = tweened(0, {
		duration: 500,
		easing: cubicOut,
    interpolate: (a, b) => {
      console.log('a,b', a, b)
      return (t) => {
        console.log('t', t);
-       return t;
+       return (b - a) * t;
      }
    }
	});
</script>

<button on:click={() => $value = 100}>change</button>
<h1>{$value}</h1>
```
![[test17.gif]]
#### tween.js

我们可以使用其他补间动画库如 [tween.js](https://github.com/tweenjs/tween.js/tree/main)来完成的补间动画。

```html
<script>
  import { tweened } from "svelte/motion";
  import { cubicOut } from "svelte/easing";

  const size = tweened(1, {
    duration: 400,
    easing: cubicOut,
  });

  const scale1 = () => {
    $size += 1;
  };
</script>

<button on:click={scale1}> scale </button>
<div class="box" style="transform: scale({$size}); transform-origin: 0 0"></div>

<style>
  .box {
    width: 100px;
    height: 100px;
    background: red;
    border-radius: 50%;
    margin-bottom: 100px;
  }
</style>
```
![[test18.gif]]
这是一个正常使用Svelte的tween的例子，如果我们使用tween.js来实现，则需要：
```html
<script>
  import * as TWEEN from "@tweenjs/tween.js";
  
  let size2 = 1;
  let size2Tweened = size2;

  const scale2 = () => {
    let oldSize2 = size2;
    size2 += 1;
    new TWEEN.Tween({
      value: oldSize2,
    })
      .to({ value: size2 }, 400)
      .easing(TWEEN.Easing.Cubic.Out)
      .start().onUpdate(({value}) => {
        size2Tweened = value;
      });
  };

  animate();

  function animate(time) {
    TWEEN.update(time);
    requestAnimationFrame(animate);
  }
</script>

<button on:click={scale2}> scale2 </button>
<div
  class="box"
  style="transform: scale({size2Tweened}); transform-origin: 0 0"
></div>
```

### Spring

Spring弹性动画可以让UI交互的效果更接近我们的日常生活，比起像补间动画那样程序式地平滑改动，弹性动画可以运用弹性的物理特性，来让物体运动表现得更为自然生动。

spring方法的参数如下：
```javascript
function spring<T = any>(
	value?: T | undefined,
	opts?: SpringOpts | undefined
): Spring<T>;
```

同样参数value是初始值，opts是一个对象，该对象有以下属性：
- `stiffness`：表示刚度，其值介于0和1之间，值越高表示弹簧越紧。
- `damping`：表示阻尼，其值介于0和1之间，值越低表示弹跳阻尼越小。
- `precision`：表示精度，弹跳被认为处于静止状态的阈值，越低则越精确。

framer-motion

  

阻尼值
  
## Easing


  缓动方程https://web.archive.org/web/20190805215728/http://robertpenner.com/easing/

### timing-function
### cubic-bezier

https://matthewlein.com/tools/ceaser

贝塞尔曲线

[timing-function](https://tympanus.net/codrops/css_reference/timing-function_value/)

  

timing-function ease-function 数学函数

  

transition-timing-function: `<timing-function>`

animation-timing-function: `<timing-function>`

  

介绍timing-function的各属性值

  

在CSS中支持使用3种方式来定义一个函数:1、使用预定义的关键字。2、使用步进函数。3、使用cubic-bezier函数（三次贝兹曲线函数）

  

css中的

```

ease: cubic-bezier(0.25, 0.1, 0.25, 1.0)

linear: cubic-bezier(0.0, 0.0, 1.0, 1.0)

ease-in: cubic-bezier(0.42, 0, 1.0, 1.0)

ease-out: cubic-bezier(0, 0, 0.58, 1.0)

ease-in-out: cubic-bezier(0.42, 0, 0.58, 1.0)

```

  

```

<timing-function> = ease | linear | ease-in | ease-out | ease-in-out |

step-start | step-end | steps(<integer>[, [ start | end ] ]?) |

cubic-bezier(<number>, <number>, <number>, <number>)

</number></number></number></number></integer></timing-function>

```

  

todo: 看一下源码，对照一些数学公式，https://easings.net/

https://developer.mozilla.org/zh-CN/docs/Web/CSS/easing-function

使用自定义贝塞尔来实现动效和用css的timing-function来实现，看效果是否一致

  

比如我们选择easeOutBounce

![[image-11.png]]

它对应的公式如下

```javascript
function easeOutBounce(x: number): number {
  const n1 = 7.5625;

  const d1 = 2.75;

  if (x < 1 / d1) {
    return n1 * x * x;
  } else if (x < 2 / d1) {
    return n1 * (x -= 1.5 / d1) * x + 0.75;
  } else if (x < 2.5 / d1) {
    return n1 * (x -= 2.25 / d1) * x + 0.9375;
  } else {
    return n1 * (x -= 2.625 / d1) * x + 0.984375;
  }
}
```

再看packages/svelte/src/runtime/easing/index.js中的

```javascript
/**
* https://svelte.dev/docs/svelte-easing
* @param {number} t
* @returns {number}
*/

export function bounceOut(t) {
  const a = 4.0 / 11.0;
  const b = 8.0 / 11.0;
  const c = 9.0 / 10.0;

  const ca = 4356.0 / 361.0;
  const cb = 35442.0 / 1805.0;
  const cc = 16061.0 / 1805.0;

  const t2 = t * t;

  return t < a
    ? 7.5625 * t2
    : t < b
    ? 9.075 * t2 - 9.9 * t + 3.4
    : t < c
    ? ca * t2 - cb * t + cc
    : 10.8 * t * t - 20.52 * t + 10.72;
}
```

  

## Transition

  

过渡效果

  

### transition:*fn*

  

svelte/transition

  

fade

blur

fly

slide

scale

draw

  

### in: *fn* /out:*fn*

  

我们可以监听以下过渡效果的事件：

  

introstart：进入效果开始

introend：进入效果结束

outrostart：退出效果开始

outroend：退出效果结束

  

## Animation

  

动画

  

#### animate:*fn*

  
  

## 小结

tweened() 與 spring() 都有著與 store 相同的 set()、update() 方法，實際上，tweened() 與 spring() 就是上一集介紹過的 custom store

Tweening 指的是起末兩狀態間的過渡狀態，Svelte 提供了 tweened() 幫我們處理掉 tweening 的工作

Tweening 中間的過渡模式稱為 easing，有許多業界既有的 easing 模式可選用

spring() 一樣是處理過渡狀態，並且是產生 Q 彈的彈簧效果