好看的动画往往能给页面带来锦上添花的效果，不仅能提升用户体验，还能增强页面美观度。流畅丝滑的动效背后，除了开发时的灵感迸发，也需要强有力的数学知识的支持。Svelte中集成了多个服务于动画效果的方法：
* svelte/motion
* svelte/easing
* svelte/transition
* svelte/animation

## Motion

Motion指运动效果，svelte/motion导出了两个方法tweened和spring。使用这两个方法得到的值是一个可写状态的store。
  
### Tweened

Tweened即补间动画。补间（动画）（来自 [in-between](https://en.wikipedia.org/wiki/Inbetweening)）是一个概念，允许用户以平滑的方式更改对象的属性。我们只需告诉它哪些属性要更改，当补间结束运行时它们应该具有哪些最终值，以及这需要多长时间，补间引擎将负责计算从起始点到结束点的值。补间动画的状态会在固定的时间间隔内不断更新其值。

比如在我们设置css时，我们设置了元素的起点和终点，而至于过程是怎么运动的，则由电脑来决定。
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .box {
        width: 100px;
        height: 100px;
        border: 1px solid orange;
        transition: all 1s ease-in-out;
      }

      .move {
        transform: translate(100px, 100px);
      }
    </style>
  </head>
  <body>
    <button>move</button>
    <div class="box"></div>
    
    <script>
      let button = document.querySelector('button');
      let boxRef = document.querySelector(".box");
      
      button.addEventListener('click', onMove);

      function onMove() {
        if (boxRef) {
          boxRef.classList.add("move");
        } 
      };
    </script>
  </body>
</html>
```

![[test59.gif]]
我们只设置了开头和结尾的位置，以及开头运动到结尾需要1s，期间的运动过程则交由底层处理。这种设置方式不管是在设置ppt动画，制作视频剪辑中都非常常见。

笔者先演示一个不带动画的例子：
```html
<script>
  import { writable } from "svelte/store";

  const progress = writable(0);
</script>

<progress value={$progress}></progress>

{#each [0, 0.25, 0.5, 0.75, 1] as p}
  <button on:click={() => ($progress = p)}>
    {p * 100}%
  </button>
{/each}

<style>
  progress {
    display: block;
    width: 100%;
  }
</style>
```

![[test72.gif]]

当我们使用了补间动画后：
```html
<script>
  import { tweened } from "svelte/motion";
  import { cubicOut } from 'svelte/easing';

	const progress = tweened(0, {
		duration: 300,
		easing: cubicOut
	});
</script>

<progress value={$progress}></progress>

{#each [0, 0.25, 0.5, 0.75, 1] as p}
  <button on:click={() => ($progress = p)}>
    {p * 100}%
  </button>
{/each}

<style>
  progress {
    display: block;
    width: 100%;
  }
</style>
```
因为返回值是一个store，我们可以像正常使用store一样使用`$store`。

![[test73.gif]]

看下tweened的接收参数：
```javascript
function tweened<T>(
	value?: T | undefined,
	defaults?: TweenedOptions<T> | undefined
): Tweened<T>;
```
第一个参数接收一个初始值，第二个参数稍微复杂，是一个对象，能够接收以下参数：
* delay：补间延迟多少毫秒之后开始
* duration：补间效果的持续时间（以毫秒为单位）
* easing：在下一节中详细讲解
* interpolate：一个自定义的 (starting, target) => t => value 函数，用于在任意值之间进行插值。starting是起始值，target是目标值，t是0到1的数值，value是返回结果。

#### interpolate

interpolate是“插值”的意思，默认情况下，Svelte 将在数字、日期以及形状相同的数组和对象之间进行插值（只要它们仅包含数字和日期或其他有效的数组和对象）。如果我们想要插值（例如）颜色字符串或变换矩阵，需要我们自己提供自定义插值器。

比如，我们将数组进行转换：
```html
<script>
  import { tweened } from "svelte/motion";
  import { cubicOut } from 'svelte/easing';

	const arr = tweened([1, 2, 3, 4, 5], {
		duration: 500,
		easing: cubicOut
	});
</script>

<button on:click={() => $arr = [6, 7, 8, 9, 10]}>change</button>

{#each $arr as item}
  <div>{item}</div>
{/each}
```
  
![[test74.gif]]
这里的gif图由于帧率问题，只看出了几次变化，然而我们真实的页面改动频率则高得多。

再比如，如果我们需要进行颜色改变的补间动画，会使用到[d3-interpolate](https://d3js.org/d3-interpolate)：
```html
<script>
  import { tweened } from "svelte/motion";
  import { cubicInOut } from 'svelte/easing';
  import { interpolate } from "d3-interpolate";

  let colors = ['red', 'blue', 'green', 'pink'];
  let color = tweened('red', {
    duration: 1000,
    easing: cubicInOut,
    interpolate: interpolate,
  });

  const changeColor = (c) => {
    $color = c;
  }
</script>

{#each colors as color}
  <button on:click={() => changeColor(color)}>{color}</button>  
{/each}
<h2 style="color: {$color}">{$color}</h2>
```

![[test75.gif]]

interpolate的要求必须是`(a, b) => t => value`格式的函数，我们简单看下各参数的意义：
```html
<script>
  import { tweened } from "svelte/motion";
  import { cubicOut } from 'svelte/easing';

	const value = tweened(0, {
		duration: 500,
		easing: cubicOut,
    interpolate: (a, b) => {
      console.log('a,b', a, b)
      return (t) => {
        console.log('t', t);
        return t;
      }
    }
	});
</script>

<button on:click={() => $value = 100}>change</button>
<h1>{$value}</h1>
```
![[test16.gif]]
从打印的结果中，我们可以推断出，a是初始值，b是下一次更改的值，t是百分率，关键就在于t。
通过t的变化，我们可以丝滑地改动我们的变化值，当最终值无法超过b。

```diff
<script>
  import { tweened } from "svelte/motion";
  import { cubicOut } from 'svelte/easing';

	const value = tweened(0, {
		duration: 500,
		easing: cubicOut,
    interpolate: (a, b) => {
      console.log('a,b', a, b)
      return (t) => {
        console.log('t', t);
-       return t;
+       return (b - a) * t;
      }
    }
	});
</script>

<button on:click={() => $value = 100}>change</button>
<h1>{$value}</h1>
```
![[test17.gif]]
#### tween.js

我们可以使用其他补间动画库如 [tween.js](https://github.com/tweenjs/tween.js/tree/main)来完成的补间动画。

```html
<script>
  import { tweened } from "svelte/motion";
  import { cubicOut } from "svelte/easing";

  const size = tweened(1, {
    duration: 400,
    easing: cubicOut,
  });

  const scale1 = () => {
    $size += 1;
  };
</script>

<button on:click={scale1}> scale </button>
<div class="box" style="transform: scale({$size}); transform-origin: 0 0"></div>

<style>
  .box {
    width: 100px;
    height: 100px;
    background: red;
    border-radius: 50%;
    margin-bottom: 100px;
  }
</style>
```
![[test18.gif]]
这是一个正常使用Svelte的tween的例子，如果我们使用tween.js来实现，则需要：
```html
<script>
  import * as TWEEN from "@tweenjs/tween.js";
  
  let size2 = 1;
  let size2Tweened = size2;

  const scale2 = () => {
    let oldSize2 = size2;
    size2 += 1;
    new TWEEN.Tween({
      value: oldSize2,
    })
      .to({ value: size2 }, 400)
      .easing(TWEEN.Easing.Cubic.Out)
      .start().onUpdate(({value}) => {
        size2Tweened = value;
      });
  };

  animate();

  function animate(time) {
    TWEEN.update(time);
    requestAnimationFrame(animate);
  }
</script>

<button on:click={scale2}> scale2 </button>
<div
  class="box"
  style="transform: scale({size2Tweened}); transform-origin: 0 0"
></div>
```

### Spring

Spring弹性动画可以让UI交互的效果更接近我们的日常生活，比起像补间动画那样程序式地平滑改动，弹性动画可以运用弹性的物理特性，来让物体运动表现得更为自然生动。

spring方法的参数如下：
```javascript
function spring<T = any>(
	value?: T | undefined,
	opts?: SpringOpts | undefined
): Spring<T>;
```

同样参数value是初始值，opts是一个对象，该对象有以下属性：
- `stiffness`：表示刚度，其值介于0和1之间，值越高表示弹簧越紧。
- `damping`：表示阻尼，其值介于0和1之间，值越低表示弹跳阻尼越小。
- `precision`：表示精度，弹跳被认为处于静止状态的阈值，越低则越精确。

framer-motion

 TODO: tweened() 與 spring() 都有著與 store 相同的 set()、update() 方法，實際上，tweened() 與 spring() 就是上一集介紹過的 custom store 

阻尼值
  
## Easing

在CSS中，我们通常会设置诸如`transition: all 1s ease`、`animation: animationEffect 0.5s ease` 等来实现过渡或者动画效果，而在`svelte/motion`的`tweened`方法中，我们也接触到了一个参数`easing`，在这一小节，我们来了解一下“计时函数”（timing-function）。

CSS 中的 `<timing-function>`是一个（数学）函数，它被用来指定物体随着时间的推移，从一个值转换到另一个值时速度。 它描述了过渡或动画将如何在其持续时间的一个周期内进行。timing-function也称为[easing-function](https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function)。

计时函数通常作为[transition-timing-function](https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function)属性和[animation-timing-function](https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timing-function)属性的值来使用。

在CSS中支持使用3种方式来定义计时函数：
- 使用预定义的关键字
- 使用步进函数
- 使用cubic-bezier函数（三次贝塞尔曲线函数）

```
<timing-function> = ease | linear | ease-in | ease-out | ease-in-out |
step-start | step-end | steps(<integer>[, [ start | end ] ]?) |
cubic-bezier(<number>, <number>, <number>, <number>)
```

也就是说我们设置效果时可以这样：
```css
transition: all 1s ease;

transition: all 1s steps();

transition: all 1s cubic-bezier()
```

### cubic-bezier

我们可以自定义三次贝塞尔曲线来创建自定义缓动效果甚至弹跳效果。感兴趣的读者可研读[贝塞尔曲线]的实现。

#### 预定义关键字

CSS中的预定义关键字的timing-function有：`ease | linear | ease-in | ease-out | ease-in-out`，其实它们都是贝塞尔曲线的特定实现。
```css
ease: cubic-bezier(0.25, 0.1, 0.25, 1.0)
linear: cubic-bezier(0.0, 0.0, 1.0, 1.0)
ease-in: cubic-bezier(0.42, 0, 1.0, 1.0)
ease-out: cubic-bezier(0, 0, 0.58, 1.0)
ease-in-out: cubic-bezier(0.42, 0, 0.58, 1.0)
```

```html
<script>
  let animating = false;
  const startMove = () => {
    animating = true;
  }
</script>

<button on:click={startMove}>animate</button>
<div class="ball red-ball" class:ease={animating}></div>
<div class="ball red-ball" class:ease-cubic={animating}></div>
<div class="ball green-ball" class:linear={animating}></div>
<div class="ball green-ball" class:linear-cubic={animating}></div>

<style>
  .ball {
    width: 50px;
    height: 50px;
    border-radius: 50%;
  }
  .red-ball {
    background-color: red;
  }
  .green-ball {
    background-color: aquamarine;
  }

  .ease {
    animation: moveEffect 2s ease;
    animation-iteration-count: infinite;
  }
  .ease-cubic {
    animation: moveEffect 2s cubic-bezier(0.25, 0.1, 0.25, 1.0);
    animation-iteration-count: infinite;
  }
  .linear {
    animation: moveEffect 2s linear;
    animation-iteration-count: infinite;
  }
  .linear-cubic {
    animation: moveEffect 2s cubic-bezier(0.0, 0.0, 1.0, 1.0);
    animation-iteration-count: infinite;
  }

  @keyframes moveEffect {
    0% {
      transform: translateX(0);
    }
    50% {
      transform: translateX(200px);
    }
    100% {
      transform: translateX(0);
    }
  }
</style>
```

![[test84.gif]]
#### 工具

我们可以在[easings.net]( https://easings.net/)中查看关键字和贝塞尔曲线之间的转换。

比如我们选择[easeOutCirc](https://easings.net/#easeOutCirc)：
![[Pasted image 20240320171637.png]]
它对应的公式如下：
```javascript
function easeOutCirc(x: number): number {
  return Math.sqrt(1 - Math.pow(x - 1, 2));
}
```

再看`packages/svelte/src/runtime/easing/index.js`中的：
```javascript
export function circOut(t) {
	return Math.sqrt(1 - --t * t);
}
```
发现和easing.net上的实现无异。

除了easing.next，网络上有大量方便的贝塞尔曲线工具网站，比如[cubic-bezier.com](https://cubic-bezier.com/#.17,.67,.83,.67)和[ceaser](https://matthewlein.com/tools/ceaser)等，读者可自行探索。

### svelte/easing
在Svelte中，`svelte/easing`中实现了大量的缓动效果：
![[Pasted image 20240320172945.png]]

我们以`cirInOut`为例（功能太多，不一一举例了）：
```html
```

https://github.com/sveltejs/svelte/pull/525
追根溯源：https://github.com/glslify/glsl-easings
## Transition

过渡效果
### transition:*fn*

svelte/transition

fade

blur

fly

slide

scale

draw

  

### in: *fn* /out:*fn*

  

我们可以监听以下过渡效果的事件：

  

introstart：进入效果开始

introend：进入效果结束

outrostart：退出效果开始

outroend：退出效果结束

  

## Animation

目前`svelte/animation`中只导出了一个方法
  

## 小结


