
我们在解读源码时，会遇到一行这样的代码：
```javascript
component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31))
```

如果没有接触过位运算的读者，可能会对这行代码犯迷糊，因此，笔者准备花一章的时间来和大家一起了解“位运算”。

## 二进制编码
在了解位运算之前，我们需要首先了解下二进制编码方式。我们主要了解*原码*、*反码*和*补码*。
原码、反码和补码

### 原码

原码：最高位表示正负、其他位表示数值。

假设我们有8位的二进制数，如果用原码来表示，最高位则用来表示正负，剩余7位用来表示二进制数：
```
// +13
00001101

// -13 只有第一位不一样
10001101
```

使用原码来表示二进制数的优点是对开发者阅读友好，缺点是对计算机不友好，计算机无法直接用原码进行运算，否则可能会出错。

比如一个非常经典的问题：在数学运算中，`1 + (-1) = 0`这是毫无疑问的，而在二进制中，
```
 00000001
+10000001
_________
 10000010
```
运算结果变成了-2，显然出错了。

### 反码

**反码** 是在原码的基础上，保留符号位，正数不变，负数的数值位全部“取反”。

如果我们把上述的`1+(-1)`问题用反码来解决：
```
 00000001
+11111110
_________
 11111111
```
可以看到，得到的结果`11111111`是-0。理论上来说0和-0是一样的，但同一个数字有两种表示会让我们在开发时产生不必要的判断，补码则能解决这个问题。

### 补码
**补码** 是在反码的逻辑基础上进一步改动，符号位仍然不变，同样正数不改，而负数数值在原来的基础上`+1`。

```
// 13原码、反码、补码
00001101

// -13原码
10001101

// -13反码
11110010

// -13补码
11110011
```

如果我们使用补码来进行计算：
```
  00001101 (13)
+ 11110011 (-13)
________________
 100000000
```

多出来的一位会因为溢出被忽略掉，于是 `a + -a = 0` 仍然成立。这样设计之后`-0`就不存在了。
在计算机系统底层，数值一律用补码来表示和运算。

## 位运算

程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对数据在内存中的二进制位进行操作。
在javascript中，位运算符是用来对二进制位进行操作的符号，可以将二进制位从低位到高位对齐后进行运算。javascript中支持的位运算符有：“&”、“|”、“^”、“~”、“>”、“>>>”。
JS 中所有的数字都是符合 `IEEE-754` 标准的 `64` 位双精度浮点类型，而做位运算时所有的运算数以及运算结果只会保留[32位](https://262.ecma-international.org/5.1/#sec-11.10)的整数。

### 按位与 &

当两个位都是1时，结果为为1，否则为0：

```
  00000000 00000000 00000000 00001101 (13)
& 00000000 00000000 00000000 00000110 (6)
_____________________________________
  00000000 00000000 00000000 00000100 (4)
```

比如我们可以用`&`来判断奇偶性。
```javascript
3 & 1 // 1
2 & 1 // 0
```
结果是1表示是奇数，结果是0则是偶数。
原理就是1的32为二进制是最低位为1，其他为为0的值，用来判断的数字X如果是奇数，最低位一定是1，两个1相与，一定是1，而X的其他位不管是1还是0，遇到0时都变成0。

### 按位或 |

两个位都是0时，结果为为0，否则为1：
```
  00000000 00000000 00000000 00001101 (13)
| 00000000 00000000 00000000 00000110 (6)
_____________________________________
  00000000 00000000 00000000 00001111 (15)
```

### 按位异或 ^

两个位相同时，结果为0，否则为1。任何数和自身异或结果都为零，和零异或结果都是其本身。

```
  00000000 00000000 00000000 00001101 (13)
^ 00000000 00000000 00000000 00000110 (6)
_____________________________________
  00000000 00000000 00000000 00001011 (11)
```

### 按位非 ~

按位原来是 1 变为 0，0 变为 1。
```
~ 00000000 00000000 00000000 00001101 (13)
_____________________________________
  11111111 11111111 11111111 11110010 补码
  11111111 11111111 11111111 11110001 反码
  10000000 00000000 00000000 00001110 原码 (-14)
```
以补码的形式进行操作。

### 左移 <<

把数值的二进制表示向左移位，移除的位会被遗弃，末尾补 0。

```
00000000 00000000 00000000 00001101 << 2
___________________________________
00000000 00000000 00000000 00110100 
```
这里仍然用13举例，`13 << 2`结果是52。左移一位表示乘以2，`13 << 2`相当于`13 * 2 * 2 == 52`。

### 右移 >>

把数值的二进制表示向右移位，末尾的位会被遗弃，前面缺失的位按符号位来补，符号位是 1则补1，符号位是 0则补0。

我们以-16为例：
```
10000000 00000000 00000000 00010000 原码
11111111 11111111 11111111 11101111 反码
11111111 11111111 11111111 11110000 补码 >> 2
___________________________________
11111111 11111111 11111111 11111100 补码
11111111 11111111 11111111 11111011 反码
10000000 00000000 00000000 00000100 原码                            
```

补码用来计算，原码用来展示。`-16 >> 2 == -4`。

### 无符号右移 >>>

无符号右移，顾名思义就是右移的时候，不考虑符号位，前面统统补 `0`。
仍旧以-16为例：
```
10000000 00000000 00000000 00010000 原码
11111111 11111111 11111111 11101111 反码
11111111 11111111 11111111 11110000 补码 >>> 2
___________________________________
00111111 11111111 11111111 11111100 正数补码、反码、原码相同
```
![[Pasted image 20240318171243.png]]

在javascript中，使用`parseInt`和`Number.prototype.toString`能够进行进制之间的转换。

## `component.$$.dirty`

现在，我们终于能够结合位运算的知识来解读这段代码：
```javascript
component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31))
```

**`(i / 31) | 0`** ：这里是用数组下标 `i` 除以 31，然后向下取整（任何整数数字和 `| 0` 的结果都是其本身，位运算有向下取整的功效）；
 **`(1 << (i % 31))`** ：用 `i` 对 `31` 取模，然后做左移操作；
 `|=`：再数组里的旧值进行按位或运算，更新数组。

dirty变量是个数组，里面存放了多个32位整数，整数中的每个 `bit` 表示换算成 `instance` 数组下标的变量是否发生变更

dirty数组中每一位能够标记32个变量是否为dirty

`(i / 31) | 0`就是i/31然后取整。

- 比如i=0,计算结果为0。
- i=1，计算结果为0。
- i=32，计算结果为1。

`(1 << (i % 31))`，1左移的位数为i和31求余的值。

- 比如i=0，计算结果为1<<0 => 01。
- i=1，计算结果为1 << 1 => 10。
- i=32，计算结果为1<<1 => 10。

当i=0时这行代码就变成了`component.$$.dirty[0] |= 01`,由于dirty数组在前面已经被fill为0了，所以代码就变成了`component.$$.dirty[0] = 0 | 01` => `component.$$.dirty[0] = 01`。说明从右边数第一个变量被标记为dirty。

同理当i=1时这行代码就变成了`component.$$.dirty[0] |= 10` =>`component.$$.dirty[0] = 0 | 10` => `component.$$.dirty[0] = 10`。说明从右边数第二个变量被标记为dirty

## gpt的解释

* `component.$$.dirty[(i / 31) | 0]`：这是在访问一个数组 `component.$$.dirty`的特定索引。索引是通过将 `i`除以31并向下取整（`| 0`操作符）得到的。这样做的原因是JavaScript的位操作符只能处理32位整数，所以我们将位图分割成32位的块。
* `|= (1 << (i % 31))`：这是一个位操作，用于设置位图中的特定位。`1 << (i % 31)`会创建一个只有第 `(i % 31)`位为1的数，其余位都为0。然后，`|=`操作符将这个数与 `component.$$.dirty[(i / 31) | 0]`进行位或操作，这样就可以将第 `(i % 31)`位设置为1，而不改变其他位。

总的来说，这段代码的作用是在 `component.$$.dirty`的位图中，将第 `i`位设置为1。

为什么要用 `|=运算而不直接赋值？`

因为如果出现大于32位的变量的时候，此时赋值便会出错了。

就是判断组件内的变量是否改变，如果出现一个变量，并且在html模块中被引用,则类似如下

流程，

如果有数据更新，调用

```
$$invalidate(0, count++, count);
```

这里的第一个参数便是i。这个方法便是下面方法的第三个参数

```javascript

instance(component, options.props || {}, (i, ret, ...rest) => {
  const value = rest.length ? rest[0] : ret;
  if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
    if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
    if (ready) make_dirty(component, i);
  }
  return ret;
})
```
如果发现not_equal，会调用make_dirty
```javascript
function make_dirty(component, i) {
	if (component.$$.dirty[0] === -1) {
		dirty_components.push(component);
		schedule_update();
		component.$$.dirty.fill(0);
	}
	component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
}
```
如果我们更新count变量，此时`component.$$.dirty[0]`上存储的值便是`0 | 1`后的值1
这里了会调用schedule_update()，在里面经过调度，会执行update
```javascript
function update($$) {
	if ($$.fragment !== null) {
		$$.update();
		run_all($$.before_update);
		const dirty = $$.dirty;
		$$.dirty = [-1];
		$$.fragment && $$.fragment.p($$.ctx, dirty);
		$$.after_update.forEach(add_render_callback);
	}
}
```
有个约定，如果 dirty 第一个数字存储的是 `-1` 表示当前组件是干净的
```javascript
$$.dirty = [-1];
```


最终会执行create_frament里的p方法，我们看编译出来的p方法
```javascript
if (dirty & /*count*/ 1) set_data(t4, /*count*/ ctx[0]);
```
此时dirty是1，1 & 1还是1。一个变量看不出来，我们多设两个变量。

## 其他应用

React在涉及状态、标记位、优先级操作的地方大量使用了位运算。

ReactFiberLane.js
TODO

## 小结