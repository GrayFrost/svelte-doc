在正式解读源码之前，笔者会和读者朋友们一起了解一些npm库的功能作用，每一个都和我们接下来的源码解读息息相关。在阅读完本章后，相信读者们在接下来的源码讲解中，不至于遇到一个功能库而一头雾水。


## AST

在认识工具库之前，我们需要先了解一个概念：抽象语法树（Abstract Syntax Tree，AST）。这个概念非常重要，是实现一个编译器的核心，后面介绍的各种库都是围绕这个核心概念服务的。

https://juejin.cn/post/7155151377013047304?searchId=20240313173254009C5EB0A29C710879E1

抽象语法树也有一套约定的规范 https://github.com/estree/estree?tab=readme-ov-file
https://web.archive.org/web/20210314002546/https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API

acorn.js parse 返回值符合 ESTree spec 描述的 AST 对象



#### 词法分析
Tokenization
词法分析是由词法分析器完成的,词法分析器会扫描(scanning)代码,提取词法单元
源代码分解成一个个词素

词法分析，也称之为扫描（scanner），简单来说就是调用 next() 方法，一个一个字母的来读取字符，然后与定义好的 JavaScript 关键字符做比较，生成对应的Token。Token 是一个不可分割的最小单元

整个代码将被分割进一个tokens列表


#### 语法分析
将词法分析阶段生成的 Token 转换为抽象语法树(Abstract Syntax Tree),这一过程称之为语法解析(Parsing)。

https://astexplorer.net/

Program
根节点,即代表一整颗抽象语法树,body 属性是一个数组,包含了多个 Statement 节点

ExpressionStatement
表达式语句节点,expression 属性指向一个表达式节点对象

BinaryExpression
二元运算表达式节点,left 和 right 表示运算符左右的两个表达式,operator 表示一个二元运算符

Literal
字面量

VariableDeclaration
变量声明

VariableDeclarator
变量声明的描述

Identifier
标识符节点

工具 Babel

@babel/parser : 将 js 代码 ------->>>  AST 抽象语法树；
@babel/traverse 对 AST 节点进行递归遍历；
@babel/types 对具体的 AST 节点进行进行修改；
@babel/generator :  AST 抽象语法树 ------->>> 新的 js 代码；

## acorn
如果你没有听过[acorn](https://github.com/acornjs/acorn/tree/master/acorn)，但有一个鼎鼎大名的库你一定听说过，那就是webpack。webpack底层将代码转换成抽象语法树（Abstract Syntax Tree，AST）时使用的便是acorn。

js解析器
Esprima
Acorn
UglifyJS 2
Shift

Webpack/Rollup/Babel(@babel/parser) 等都有使用


```javascript
acorn.parse(str, options)
```
str就是要解析的字符串内容，options是一个对象，其中只有ecmaVersion是必填的，用于指定指定要解析的 ECMAScript 版本。
```typescript
export interface Options {
  ecmaVersion: ecmaVersion
  sourceType?: "script" | "module"
  onInsertedSemicolon?: (lastTokEnd: number, lastTokEndLoc?: Position) => void
  onTrailingComma?: (lastTokEnd: number, lastTokEndLoc?: Position) => void
  allowReserved?: boolean | "never"
  allowReturnOutsideFunction?: boolean
  allowImportExportEverywhere?: boolean
  allowAwaitOutsideFunction?: boolean
  allowSuperOutsideMethod?: boolean
  allowHashBang?: boolean
  checkPrivateFields?: boolean
  locations?: boolean
  onToken?: ((token: Token) => void) | Token[]
  onComment?: ((
    isBlock: boolean, text: string, start: number, end: number, startLoc?: Position,
    endLoc?: Position
  ) => void) | Comment[]
  ranges?: boolean
  program?: Node
  sourceFile?: string
  directSourceFile?: string
  preserveParens?: boolean
}
```
目前我们只需大概了解参数即可，感兴趣的读者可阅读[acorn](https://github.com/acornjs/acorn/tree/master/acorn/)了解其他参数的功能。

```javascript
import * as acorn from "acorn";

let str = `let a = 0;
let b = 1;
let c = a + b;

a++;
window.e = 2;
f = 3;
`

const ast = acorn.parse(str, {
  ecmaVersion: 2023
});

console.log(ast);
```

![[Pasted image 20240313171042.png]]


我们在[AST Explorer](https://astexplorer.net/)中，得到的是同样的结果：
![[Pasted image 20240313170854.png]]

使用acorn解析之后得到的数据便是ast抽象语法树，树形结构的数据必然存在一个或多个叶子节点，在每个节点上，都有一个参数type来标记这个节点属于什么类型。我们了解一下在一个AST对象中的各种type的意义。

### type
#### Literal
Literal是字面量的意思，比如 `let str = 'svelte'`中`'svelte'`就是一个字符串字面量
![[Pasted image 20240326150144.png]]
![[Pasted image 20240326150049.png]]
#### Identifier
Identifier指标识符，变量名、属性名、参数名等各种声明和引用的名字，都是Identifer。
```javascript
const str = 'world';

function greet(val) {
  console.log(val);
}

const foo = {
  bar: 'svelte'
}
```
就拿这一小段代码来说，它的Identifier类型节点就将近十个：
![[Pasted image 20240326151048.png]]

#### Statement
语句，一些常见的执行代码用此类型，比如：

`{}`是`BlockStatement`
![[Pasted image 20240326151939.png]]
`do {} while()`是`DoWhileStatement`
![[Pasted image 20240326152044.png]]
`debugger`是`DebuggerStatement`
![[Pasted image 20240326152820.png]]

`$:xxx`是`LabeledStatement`。Svelte中的反应性的监听，巧妙地运用了这个语句。
![[Pasted image 20240326153111.png]]
不再逐一展示。以下是常见语句：
```
{} // BlockStatement

do {} while() // DoWhileStatement
while() {} // WhileStatement
for(let i = 0; i < n; i++){} // ForStatement
for(let i in obj){} // ForInStatement
for(let i of arr){} // ForOfStatement

debugger; // DebuggerStatement
throw Error(); // ThrowStatement
label: xxx // LabeledStatement
break; // BreakStatement
continue; // ContinueStatement
return; // ReturnStatement

if(true) {} // IfStatement
switch(true) {} // SwitchStatement

try {} catch(e) {} // TryStatement
...等等
```
#### Declaration
相比于Statement语句用来控制执行逻辑，Declaration声明语句将非空标识符绑定到常量、Class、变量、函数或导入导出当中。
![[Pasted image 20240326155402.png]]

![[Pasted image 20240326155457.png]]
![[Pasted image 20240326155551.png]]
```
let a = ''; // VariableDeclaration
function a() {} // FunctionDeclaration
class A {} // ClassDeclaration
import a from 'a'; // ImportDeclaration
export default a = 1; // ExportDefaultDeclaration
...等等
```
#### Expression
Expression表达式，通过调用运算符或者函数来得到一个计算后的返回值。

```
[1,2,3] // ArrayExpression                数组表达式
({a: ''}) // ObjectExpression             对象表达式
this; // ThisExpression                   this表达式

1 + 2 // BinaryExpression                 二元表达式
true ? '' : '' // ConditionalExpression   条件表达式
a++; // UpdateExpression                  更新表达式
-1 // UnaryExpression                     一元表达式

a = 1; // AssignmentExpression            赋值表达式
new a(); // NewExpression                 New表达式
a = function() {} // FunctionExpression   函数表达式
() => {} // ArrowFunctionExpression       箭头函数表达式
...等等
```

#### Program
正常情况下，最顶级的节点的type即是Program


还有Class、Modules、Directive、File、Comment等type不一一演示了。
https://cloud.tencent.com/developer/article/1842134

## periscopic
https://github.com/Rich-Harris/periscopic#readme
从ast对象中分析出变量作用域。

```javascript
import { analyze } from 'periscopic';

const ast = acorn.parse(`
...
...
...
`);

const { map, globals, scope } = analyze(ast);
```

### 参数
#### analyze

`periscopic`导出一个方法`analyze`，调用此方法得到一个对象，该对象有以下属性：
- `map`：是一个WeakMap类型的对象（`WeakMap<Node, Scope>`）, 对象的keys是创建出scope的ast节点。
- `globals`：是一个Map类型的对象（`Map<string, Node>`），收集所有被引用的但没有被声明的Identifier，Identifier我们在acorn中已详细讲解。
- `scope`：程序中的顶级作用域，`Scope`类型

```javascript
import * as acorn from 'acorn';
import { analyze } from 'periscopic';

let a = `let a = 0;
window.b = 1;
function c() {
  let d = 2;
}
e = 3;
`;

const ast = acorn.parse(a, {
  ecmaVersion: 2023,
});

const { map, globals, scope } = analyze(ast);
console.log('map', map);
console.log('globals', globals);
console.log('scope', scope);
```

![[Pasted image 20240326165056.png]]
我们首先看下map的打印数据：
periscopic分析出两个创建了scope的节点。
![[Pasted image 20240326170452.png]]
![[Pasted image 20240326170533.png]]

globals中我们可以得知，`e`和`window`这两个变量我们没有进行声明而直接用了。
![[Pasted image 20240326170620.png]]

scope，top-level级别的作用域
![[Pasted image 20240326170819.png]]
##### Scope
 `Scope`类型的对象有以下参数:
- `scope.block`：如果scope是BlockStatement创建的，则是true，否则是false
- `scope.parent`：父级的Scope对象
- `scope.declarations`：一个Map类型对象（`Map<string, Node>` ），在当前scope中声明的所有变量，Node节点值是Declaration类型节点
- `scope.initialised_declarations`：一个Set类型对象（`Set<string>`），在当前scope中声明且初始化了的对象
- `scope.references`：一个Set类型对象（`Set<string>` ），在当前scope中的所有变量名

`Scope`类型对象有两个方法：
- `scope.has(name)`：如果`name`在当前作用域或祖先作用域中声明过，则返回`true`
- `scope.find_owner(name)`：返回声明`name`的`Scope`对象

我们以上述例子`const { map, globals, scope } = analyze(ast)`中返回的scope为例：
![[Pasted image 20240326172229.png]]
block：不是BlockStatement创建的，所以false
parent：没有父级作用域，所以null
declarations: 变量a和c是在当前作用域声明的
initialised_declarations: 变量a在当前作用域声明并且初始化
references: 当前作用域中的变量有a、window、c、d、e

#### extract

periscopic还导出了两个方法`extract_identifiers`和`extract_names`用来提取特定值。

```javascript
import * as acorn from 'acorn';
import { extract_identifiers, extract_names } from 'periscopic';

let a = `let a = 0;
window.b = 1;
function c() {
  let d = 2;
}
e = 3;
`;

const ast = acorn.parse(a, {
  ecmaVersion: 2023,
});

const data = ast.body[2].id;
const identifiers = extract_identifiers(data);
const names = extract_names(data);
console.log('identifiers', identifiers);
console.log('names', names);
```

![[Pasted image 20240326174611.png]]

在控制台中输出：
![[Pasted image 20240326174503.png]]
## estree-walker
https://github.com/Rich-Harris/estree-walker#readme

Inside the enter function, calling this.skip() will prevent the node's children being walked, or the leave function (which is optional) being called.

Call this.replace(new_node) in either enter or leave to replace the current node with a new one.

Call this.remove() in either enter or leave to remove the current node.

具有相同作用的包还有：estraverse、acorn-walk等。

### 参数

## escodegen
https://github.com/estools/escodegen
用于把满足 Estree 标准的 AST 转换为 ESMAScript 代码

## 小结
通过介绍这几个库，相信笔者已经发现，这些其实就是实现一个编译器所需要的几个功能：解析代码文件 -> 分析ast，ast转换 ->生成新代码。