

[hello world demo](https://www.svelte.cn/repl/hello-world?version=3.59.2)

```html
<script>
  let name = 'world';
</script>

<h1>Hello {name}!</h1>
```


```javascript
/* App.svelte generated by Svelte v3.59.2 */
import {
  SvelteComponent,
  detach,
  element,
  init,
  insert,
  noop,
  safe_not_equal
} from "svelte/internal";

function create_fragment(ctx) {
  let h1;

  return {
    c() {
      h1 = element("h1");
      h1.textContent = `Hello ${name}!`;
    },
    m(target, anchor) {
      insert(target, h1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) detach(h1);
    }
  };
}

let name = 'world';

class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment, safe_not_equal, {});
  }
}

export default App;
```

编译后的代码包括三部分：create_fragment, name变量的声明，App类。

create_fragment中的c代表create，m代表mount, insert会调用target.insertBefore, d代表detach移除。

todo: 添加一些更改状态的代码，观察编译后的代码


组件继承SvelteComponent类，实例化时会调用init方法，create_fragment在init中被调用


```html
<script>
  let name = 'world';
  const updateName = () => {
    name = 'svelte';
  }
</script>

<h1 on:click={updateName}>Hello {name}!</h1>
```

```javascript
/* App.svelte generated by Svelte v3.59.2 */
import {
  SvelteComponent,
  append,
  detach,
  element,
  init,
  insert,
  listen,
  noop,
  safe_not_equal,
  set_data,
  text,
} from "svelte/internal";

function create_fragment(ctx) {
  let h1;
  let t0;
  let t1;
  let t2;
  let mounted;
  let dispose;

  return {
    c() {
      h1 = element("h1");
      t0 = text("Hello ");
      t1 = text(/*name*/ ctx[0]);
      t2 = text("!");
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      append(h1, t0);
      append(h1, t1);
      append(h1, t2);

      if (!mounted) {
        dispose = listen(h1, "click", /*updateName*/ ctx[1]);
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /*name*/ 1) set_data(t1, /*name*/ ctx[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) detach(h1);
      mounted = false;
      dispose();
    },
  };
}

function instance($$self, $$props, $$invalidate) {
  let name = "world";

  const updateName = () => {
    $$invalidate(0, (name = "svelte"));
  };

  return [name, updateName];
}

class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {});
  }
}

export default App;

```

编译后的代码多了一些改动点：create_fragment方法中的m()内部增加了点击事件的监听；还多了一个p()方法，用于数据更新；原来在全局声明的name变量赋值转为了在instance方法中xxxxxx


我们从github上下载svelte的源码，继续按照官网repl的版本3.59.2来查看源码逻辑

在src/compiler/compile/render_dom/Block.ts中

```typescript
const return_value: any = x`{
  key: ${properties.key},
  first: ${properties.first},
  c: ${properties.create},
  l: ${properties.claim},
  h: ${properties.hydrate},
  m: ${properties.mount},
  p: ${properties.update},
  r: ${properties.measure},
  s: ${properties.restore_measurements},
  f: ${properties.fix},
  a: ${properties.animate},
  i: ${properties.intro},
  o: ${properties.outro},
  d: ${properties.destroy}
}`;
```

或者在src/runtime/internal/types.ts

```typescript
export interface Fragment {
  key: string | null;
  first: null;
  /* create  */ c: () => void;
  /* claim   */ l: (nodes: any) => void;
  /* hydrate */ h: () => void;
  /* mount   */ m: (target: HTMLElement, anchor: any) => void;
  /* update  */ p: (ctx: T$$['ctx'], dirty: T$$['dirty']) => void;
  /* measure */ r: () => void;
  /* fix     */ f: () => void;
  /* animate */ a: () => void;
  /* intro   */ i: (local: any) => void;
  /* outro   */ o: (local: any) => void;
  /* destroy */ d: (detaching: 0 | 1) => void;
}
```

c(create): 创建DOM节点

m(mount): 挂载DOM节点到target上

p(update):组件数据发生变更时触发，在这个方法里检查更新

d(destroy): 移除挂载，取消事件绑定


从刚在编译的代码中，我们可以看到从svelte/internal中引入了append,detach等方法。

在src/runtime/internal/dom.ts中，我们可以找到这些方法的定义

```typescript
export function append(target: Node, node: Node) {
	target.appendChild(node);
}

export function detach(node: Node) {
	if (node.parentNode) {
		node.parentNode.removeChild(node);
	}
}

export function element<K extends keyof HTMLElementTagNameMap>(name: K) {
	return document.createElement<K>(name);
}

export function insert(target: Node, node: Node, anchor?: Node) {
	target.insertBefore(node, anchor || null);
}

export function listen(node: EventTarget, event: string, handler: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions | EventListenerOptions) {
	node.addEventListener(event, handler, options);
	return () => node.removeEventListener(event, handler, options);
}

export function text(data: string) {
	return document.createTextNode(data);
}
```

`$$invalidate`做了什么？

因为instance是在init方法中被调用，我们在src/runtime/internal/Component.ts找到instance被调用的地方：

```typescript
$$.ctx = instance
		? instance(component, options.props || {}, (i, ret, ...rest) => {
			const value = rest.length ? rest[0] : ret;
			if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
				if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
				if (ready) make_dirty(component, i);
			}
			return ret;
		})
		: [];
```

第三个参数，便是 `$$invalidate`的执行，我们单独提取出来看

```typescript
(i, ret, ...rest) => {
			const value = rest.length ? rest[0] : ret;
			if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
				if (ready) make_dirty(component, i);
			}
			return ret;
		}
```

判断赋值之后不相等，就执行mark_dirty.

思考：第一个参数中的i干嘛用的？


make_dirty做了什么？

在src/runtime/internal/Component.ts中找到make_dirty的方法定义

```typescript
function make_dirty(component, i) {
	if (component.$$.dirty[0] === -1) {
		dirty_components.push(component);
		schedule_update();
		component.$$.dirty.fill(0);
	}
	component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
```

我们可能一下看不懂这段代码是干什么的，没关系，让chatgpt帮我们解答

```typescript
这段代码是在JavaScript框架Svelte中使用的，用于标记组件的某个部分（由参数i指定）为"dirty"，即需要更新。这是Svelte的响应式系统的一部分，当组件的状态改变时，它会自动更新DOM。

具体来说，这个函数的工作原理如下：

首先，它检查组件是否已经被标记为"dirty"。如果没有（即component.$$.dirty[0] === -1），那么它将组件添加到dirty_components数组中，并调度一个更新。

然后，它将组件的dirty标志位数组填充为0，表示所有部分都已清理。

最后，它将参数i指定的部分标记为"dirty"。这是通过将dirty标志位数组的相应元素设置为1来实现的。这里使用了位操作，以便在一个整数中存储多个标志位。

总的来说，这个函数的目的是在组件的状态改变时，确保只有需要更新的部分才会被重新渲染，从而提高性能。
```

了解位运算？


schedule_update做了什么？

在src/runtime/internal/scheduler.ts中

```typescript
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;

export function schedule_update() {
	if (!update_scheduled) {
		update_scheduled = true;
		resolved_promise.then(flush);
	}
}
```



flush做了什么？

在src/runtime/internal/scheduler.ts中

```typescript
let flushidx = 0;  // Do *not* move this inside the flush() function
export function flush() {
	// Do not reenter flush while dirty components are updated, as this can
	// result in an infinite loop. Instead, let the inner flush handle it.
	// Reentrancy is ok afterwards for bindings etc.
	if (flushidx !== 0) {
		return;
	}

	const saved_component = current_component;

	do {
		// first, call beforeUpdate functions
		// and update components
		try {
			while (flushidx < dirty_components.length) {
				const component = dirty_components[flushidx];
				flushidx++;
				set_current_component(component);
				update(component.$$);
			}
		} catch (e) {
			// reset dirty state to not end up in a deadlocked state and then rethrow
			dirty_components.length = 0;
			flushidx = 0;
			throw e;
		}

		set_current_component(null);

		dirty_components.length = 0;
		flushidx = 0;

		while (binding_callbacks.length) binding_callbacks.pop()();

		// then, once components are updated, call
		// afterUpdate functions. This may cause
		// subsequent updates...
		for (let i = 0; i < render_callbacks.length; i += 1) {
			const callback = render_callbacks[i];

			if (!seen_callbacks.has(callback)) {
				// ...so guard against infinite loops
				seen_callbacks.add(callback);

				callback();
			}
		}

		render_callbacks.length = 0;
	} while (dirty_components.length);

	while (flush_callbacks.length) {
		flush_callbacks.pop()();
	}

	update_scheduled = false;
	seen_callbacks.clear();
	set_current_component(saved_component);
}
```



update做了什么？

```typescript
function update($$) {
	if ($$.fragment !== null) {
		$$.update();
		run_all($$.before_update);
		const dirty = $$.dirty;
		$$.dirty = [-1];
		$$.fragment && $$.fragment.p($$.ctx, dirty);

		$$.after_update.forEach(add_render_callback);
	}
}
```
