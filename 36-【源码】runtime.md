
要了解Svelte的运行时逻辑，可以从它编译后的代码出发。我们在[REPL](https://svelte.dev/repl/hello-world?version=4.2.12)编写一个简易的程序。

```html
<script>
  let count = 0;
  const updateCount = () => {
    count++;
  }
</script>

<button on:click={updateCount}>add count</button> 
<p>count: {count}</p>
{#if count> 2}
  hello svelte!!!
{/if}
```

看下编译后的js代码：
```javascript
/* App.svelte generated by Svelte v4.2.12 */
import {
  SvelteComponent,
  append,
  detach,
  element,
  empty,
  init,
  insert,
  listen,
  noop,
  safe_not_equal,
  set_data,
  space,
  text
} from "svelte/internal";

import "svelte/internal/disclose-version";

function create_if_block(ctx) {
  let t;

  return {
    c() {
      t = text("hello svelte!!!");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}

function create_fragment(ctx) {
  let button;
  let t1;
  let p;
  let t2;
  let t3;
  let t4;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = /*count*/ ctx[0] > 2 && create_if_block(ctx);

  return {
    c() {
      button = element("button");
      button.textContent = "add count";
      t1 = space();
      p = element("p");
      t2 = text("count: ");
      t3 = text(/*count*/ ctx[0]);
      t4 = space();
      if (if_block) if_block.c();
			if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, button, anchor);
      insert(target, t1, anchor);
      insert(target, p, anchor);
      append(p, t2);
      append(p, t3);
      insert(target, t4, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);

      if (!mounted) {
        dispose = listen(button, "click", /*updateCount*/ ctx[1]);
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /*count*/ 1) set_data(t3, /*count*/ ctx[0]);

      if (/*count*/ ctx[0] > 2) {
        if (if_block) {
					
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
        detach(t1);
        detach(p);
        detach(t4);
        detach(if_block_anchor);
      }

      if (if_block) if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}

function instance($$self, $$props, $$invalidate) {
  let count = 0;

  const updateCount = () => {
    $$invalidate(0, count++, count);
  };

  return [count, updateCount];
}

class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {});
  }
}

export default App;
```

我们理一下编译后的大体逻辑：
- 首先是建一个`SvelteComponent`类，该类由`svelte/internal`导出。在`SvelteComponent`类实例化时调用`init`方法。`init`方法中比较关键的参数有`instance`和`create_fragment`。
- `instance`是一个方法，里面有用于触发响应式更新的方法`$$invalidate`。
- `create_fragment`组件完整的生命周期，包含了创建、挂载、更新和卸载等。

我们所关注的运行时逻辑都在源码仓库的`packages/svelte/src/runtime`里。
![](./img/36-1.png)

## SvelteComponent

源码路径：`packages/svelte/src/runtime/internal/Component.js`
```javascript
export class SvelteComponent {
  $$ = undefined;
  $$set = undefined;
  $destroy() {}
  $on(type, callback) {}
  $set(props) {}
}
```

`SvelteComponent`中定义了一些属性和方法，在官网的[Client-side component API](https://svelte.dev/docs/client-side-component-api)中，有介绍这些方法的使用，我们集中关注`$$`这个属性，后面大量的数据会挂载到这个属性上。

## init
`init`方法，在组件初始化时执行的唯一方法，由`svelte/internal`导出。

源码路径：`packages/svelte/src/runtime/internal/Component.js`

```javascript
export function init(
  component,
  options,
  instance,
  create_fragment,
  not_equal,
  props,
  append_styles = null,
  dirty = [-1]
) {
  const parent_component = current_component;
  set_current_component(component);
  /** @type {import('./private.js').T$$} */
  const $$ = (component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  });

  let ready = false;
  $$.ctx = instance
    ? instance(component, options.props || {}, (i, ret, ...rest) => {
        const value = rest.length ? rest[0] : ret;
        if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
          if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
          if (ready) make_dirty(component, i);
        }
        return ret;
      })
    : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
  if (options.target) {
    $$.fragment && $$.fragment.c();
    mount_component(component, options.target, options.anchor);
    flush();
  }
  set_current_component(parent_component);
}
```
这里笔者删除了一些无关代码，比如样式的添加，hydrate注水逻辑等。

先看下`init`接收的几个参数：
```javascript
init(
  component,
  options,
  instance,
  create_fragment,
  not_equal,
  props,
  append_styles = null,
  dirty = [-1]
) 
```
- component：组件实例，即组件初始化时传的this
- instance：外部传入的方法，内含数据更新逻辑
- create_fragment：外部传入的方法，组件的生命周期逻辑
- dirty：组件内的数据更新标识

init的逻辑：
- 进入`init`，首先设置当前组件为正在运行的组件，往组件的`$$`属性中挂载大量属性
- 执行`instance`方法，`instance`接收三个参数，第一个参数是组件实例，第三个参数是一个方法，其实它就是`$$invalidate`（待会分析），执行后将返回值挂载到`$$.ctx`。我们可以把`$$.ctx`理解为组件的上下文，每个组件都有自己的上下文，其中存储的是在`<script></script>`内定义的变量的值和涉及到变量更新的方法，Svelte会按照变量在组件内的声明顺序依次保存在`$$.ctx`数组当中，先保存变量，再变量方法。
- 进行更新，`run_all($$.before_update)`在`mount_component`之前，对应了我们在生命周期里了解到的第一次`beforeUpdate`是在`onMount`之前执行的。
- `create_fragment`创建组件的fragment，同时挂载到`$$.fragment`。`mount_component`挂载组件到页面上。
- 执行`flush`方法。
- 执行完这个组件的逻辑后，重置当前组件为父组件。

### instance

我们可以把`instance`方法是理解成是svelte实例的执行器，里面包含的是一个组件应该如何运行的逻辑。我们在Svelte组件中写在`<script></script>`里的代码，会被编译进`instance`方法内。每个组件在执行`init`初始化时，会调用一次`instance`方法形成自己的闭包，从而达到数据隔离的目的。

比如我们最开始的例子里：
```javascript
<script>
  let count = 0;
  const updateCount = () => {
    count++;
  }
</script>
```

被编译后，变成：
```javascript
function instance($$self, $$props, $$invalidate) {
  let count = 0;

  const updateCount = () => {
    $$invalidate(0, count++, count);
  };

  return [count, updateCount];
}
```

#### `$$invalidate`
```typescript
(i, ret, ...rest) => {
	const value = rest.length ? rest[0] : ret;
	if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
		if (ready) make_dirty(component, i);
	}
	return ret;
}
```
`$$invalidate`的逻辑：
- 首先是编译器将我们原来的赋值代码进行了更改，将`count++`转变成`$$invalidate(0, count++, count)`，看下`$$invalidate`的三个参数`(i, ret, ...rest)`：i表示是组件内的第几个变量，ret是表达式，`...rest`是剩余参数
- 首先是进行赋值`($$.ctx[i] = value)`，然后通过`not_equal`判断赋值前后的变量是否改变，如果改变了，通过`make_dirty`标记组件为dirty（非常关键！！！）

调用`$$invalidate`，会对某个改动的变量进行标记，然后在微任务中调用`flush`函数，根据变量改动的dirty标记进行局部更新。

##### make_dirty

源码路径：`packages/svelte/src/runtime/internal/Component.js`
```javascript
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
}
```

`make_dirty`的逻辑如下：
- 首先检查组件是否已经被标记为dirty。如果没有（Svelte中约定，`$$.dirty`数组的第一项如果是-1，则非dirty)，那么将组件添加到dirty_components数组中，并调度一个更新。
- 将组件的dirty标志位数组原来是`[-1]`的填充为`[0]`，既标记了组件是dirty状态，又方便后续的位运算操作
- 最后将参数i指定的部分标记为dirty，通过将dirty标志位数组的相应元素设置为1来实现的。终于轮到位运算上场！

###### schedule_update

```typescript
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;

export function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
```
在`Promise.then`微任务中执行更新。
### create_fragment

`create_fragment`是Svelte文件编译后输出的一个方法，里面包含了组件具体的生命周期。
```javascript
function create_fragment(ctx) {
  let button;
  ...
  let if_block = /*count*/ ctx[0] > 2 && create_if_block(ctx);

  return {
    c() {
      button = element("button");
      button.textContent = "add count";
      t1 = space();
      p = element("p");
      t2 = text("count: ");
      t3 = text(/*count*/ ctx[0]);
      ...
    },
    m(target, anchor) {
      insert(target, button, anchor);
      ...
      append(p, t2);
      ...

      if (!mounted) {
        dispose = listen(button, "click", /*updateCount*/ ctx[1]);
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /*count*/ 1) set_data(t3, /*count*/ ctx[0]);
    },
    d(detaching) {
      if (detaching) {
         detach(button);
        ...
      }
    }
  };
}
```

`create_fragment`的逻辑：
- `create_fragment`接收一个参数ctx，我们通过前面知道，这个ctx就是`instance`方法执行后的返回值，ctx是一个数组，包含了数据和用于更新数据的方法，比如：
![](./img/36-2.png)

- `create_fragment`方法返回一个对象，这个对象内包含 `c,m,p,i,o,d`等特殊名称的函数，这些函数并非编译混淆，而是Fragment内部的生命周期缩写，这个对象会挂载到`$$.fragment`上。
```javascript
// 源码路径：packages/svelte/src/runtime/internal/private.d.ts
export interface Fragment {
  key: string | null;
  first: null;
  /* create  */ c: () => void;
  /* claim   */ l: (nodes: any) => void;
  /* hydrate */ h: () => void;
  /* mount   */ m: (target: HTMLElement, anchor: any) =>   void;
  /* update  */ p: (ctx: T$$['ctx'], dirty: T$$['dirty'])   => void;
  /* measure */ r: () => void;
  /* fix     */ f: () => void;
  /* animate */ a: () => void;
  /* intro   */ i: (local: any) => void;
  /* outro   */ o: (local: any) => void;
  /* destroy */ d: (detaching: 0 | 1) => void;
}
```
- 在创建时，会调用封装好的`element`、`space`、`text`等方法；在挂在时调用`insert`、`append`等方法；在更新时，通过dirty数组中的值进行位运算，判断是否需要更新数据，还记得我们前面章节学习到的位运算的知识吗，在Svelte源码中，凡是涉及到dirty的地方，位运算无处不在；在卸载时调用`detach`等方法。

#### 封装

源码路径：`packages/svelte/src/runtime/internal/dom.js`
```typescript
export function append(target: Node, node: Node) {
  target.appendChild(node);
}

export function detach(node: Node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}

export function element<K extends keyof HTMLElementTagNameMap>(name: K) {
  return document.createElement<K>(name);
}

export function insert(target: Node, node: Node, anchor?: Node) {
  target.insertBefore(node, anchor || null);
}

export function listen(node: EventTarget, event: string, handler: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions | EventListenerOptions) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}

export function text(data: string) {
  return document.createTextNode(data);
}
```

### mount_component

源码路径：`packages/svelte/src/runtime/internal/Component.js`

```javascript
export function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  // onMount happens before the initial afterUpdate
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);

    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
```
调用fragment的`m()`方法，这里我们可以看到，会调用`onMount`方法，如果`onMount`有返回值，则相当于是`destroy`方法。

### flush

源码路径：`packages/svelte/src/runtime/internal/scheduler.js`

```javascript
let flushidx = 0;

export function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length) binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
```
`flush`函数的主要作用是更新和渲染组件，其步骤如下：
- 通过`flushidx !== 0`检查是否已经在更新脏组件，如果是则返回，避免无限循环。
- 先保存当前组件，然后在一个do-while循环中，首先调用`beforeUpdate`函数并更新组件。如果在更新过程中出现错误，会重置脏状态以避免死锁。
- 清空脏组件列表，重置`flushidx`，然后调用所有`bind:this`回调函数。
- 在组件更新后，调用`afterUpdate`函数。这可能会导致后续的更新，所以需要防止无限循环。之后清空渲染回调列表。
- 如果还有脏组件，重复上述步骤。
- 调用所有`flush`回调函数。清除已调用的回调函数列表。
- 恢复保存的当前组件。

这个函数的主要目的是确保所有的组件都被正确地更新和渲染，同时避免因为错误或无限循环导致的问题。

#### update
```typescript
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);

    $$.after_update.forEach(add_render_callback);
  }
}
```

一言蔽之，就是把需要更新的组件给更新了。调用 `$$.update`,调用组件里的`$$.fragment.p`方法，执行`$$.after_update`的回调。

## 更新流程

我们重新整理下组件的更新逻辑：
- 用户执行具体操作触发更新流程
- 在instance的`$$invalidate`方法中，通过`not_equal`比较操作前后`$$.ctx`中的值是否发生了改变，如果发生改变则继续执行`make_dirty`
- 执行`make_dirty`函数标记为脏值，添加带有脏值需要更新的组件，从而继续触发更新
- 执行`schedule_update`函数
- 执行`flush`函数，取出所有的脏值组件，执行update方法`update(component.$$)`
- 在`update`方法中，执行的是组件的`fragment.p`方法，p方法的逻辑就是确定需要更新组件，并操作和更新dom组件，从而完成了最后的流程

我们用以下例子来进行说明：
```html
<script>
  let count = 0;
  let count2 = 0;
</script>

<button on:click={() => count++}>add</button>
<button on:click={() => count2++}>add2</button>
{count} {count2}
```

它的编译结果如下：
```javascript
/* App.svelte generated by Svelte v4.2.12 */
import {
	...
} from "svelte/internal";

function create_fragment(ctx) {
  ...

  return {
    c() {
      button0 = element("button");
      button0.textContent = "add";
      t1 = space();
      button1 = element("button");
      button1.textContent = "add2";
      t3 = space();
      t4 = text(/*count*/ ctx[0]);
      t5 = space();
      t6 = text(/*count2*/ ctx[1]);
    },
    m(target, anchor) {
      ...

      if (!mounted) {
        dispose = [
          listen(button0, "click", /*click_handler*/ ctx[2]),
          listen(button1, "click", /*click_handler_1*/ ctx[3])
        ];

        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /*count*/ 1) set_data(t4, /*count*/ ctx[0]);
      if (dirty & /*count2*/ 2) set_data(t6, /*count2*/ ctx[1]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      ...
    }
  };
}

function instance($$self, $$props, $$invalidate) {
  let count = 0;
  let count2 = 0;
  const click_handler = () => $$invalidate(0, count++, count);
  const click_handler_1 = () => $$invalidate(1, count2++, count2);
  return [count, count2, click_handler, click_handler_1];
}

class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {});
  }
}

export default App;
```

- 当我们点击按钮1时，执行`click_handler`方法，内部调用`$$invalidate(0, count++, count)`
- `$$invalidate`内部执行`not_equal($$.ctx[i], $$.ctx[i] = value)`，i此时是0，`$$.ctx[0]`是0，执行`$$.ctx[0] = 1`之后，和原来的值不一样，执行`make_dirty`
- 首先是初始`dirty[0]`是-1，先填充为`dirty.fill(0)`，变成`dirty[0]`是0。执行`component.$$.dirty[(i / 31) | 0] |= 1 << i % 31`，`0 % 31`是0，`1<<0`仍是1，`(0 / 31) | 0`得到0，我们需要注意`component.$$.dirty[xxx] |= xxx`中间是一个位或运算。`0 | 1`得到1，最终`component.$$.dirty[0] = 1`。
- 微任务中执行`schedule_update`里的逻辑，调用`fragment.p`方法，此时`[dirty]`数组是`[1]`，`1 && 1`是1，能够执行`set_data(t4, /*count*/ ctx[0])`，`set_data`方法内通过设置`document.createTextNode().data`的值来更新页面的展示。`1 & 2`是0，不执行`set_data(t6, /*count2*/ ctx[1])`。之后`dirty`数组重新变成`[-1]`
```javascript
p(ctx, [dirty]) {
  if (dirty & /*count*/ 1) set_data(t4, /*count*/ ctx[0]);
  if (dirty & /*count2*/ 2) set_data(t6, /*count2*/ ctx[1]);
}
```

- 当点击按钮2时，执行`click_handler`方法，内部调用`$$invalidate(1, count++, count)`
- `$$invalidate`内部执行`not_equal($$.ctx[i], $$.ctx[i] = value)`，i此时是1，`$$.ctx[1]`是1，执行`$$.ctx[1] = 1`之后，和原来的值不一样，执行`make_dirty`
-  依旧是初始`dirty[0]`是-1，先填充为`dirty.fill(0)`，变成`dirty[0]`是0。执行`component.$$.dirty[(i / 31) | 0] |= 1 << i % 31`，`1 % 31`是1，`1<<1`是2，`(1 / 31) | 0`得到0，`0 | 2`得到2，最终`component.$$.dirty[0] = 2`。
- 执行`schedule_update`，调用`fragment.p`方法，此时`[dirty]`数组是`[2]`，`2 && 2`是1，能够执行`set_data(t6, /*count2*/ ctx[1])`，`2 & 1`是0，不执行`set_data(t4, /*count*/ ctx[0])`

## 小结

本章我们学习了：
- `SvelteComponent`的基本功能
- `init`方法的基本功能
- `instance`方法的基本功能，它就是把我们在`<script></script>`中定义的更新数据的方法包裹起来，然后编译成新的更新语句，同时返回一个数组，`ctx`会接收这个数组的值。
- `$$invalidate`的基本逻辑，触发更新操作的关键方法
- `make_dirty`的基本逻辑，里面有位运算的运用
- `create_fragment`的基本功能，里面包含了一个组件的基本生命周期方法
- dom操作的封装
- Svelte文件被编译后，数据更新的大体流程。
