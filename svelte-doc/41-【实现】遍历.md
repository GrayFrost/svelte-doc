## 解析子节点
在前面的章节中，我们反复提到没有支持标签内子元素的展示，而导致我们在演示时只能干写标签而无内容，在本章中我们将完善这一功能。

首先我们要改造的是parseFragments
```javascript
function parseFragments(condition) {
    const fragments = [];
    while (condition()) {
      const fragment = parseFragment();
      if (fragment) {
        fragments.push(fragment);
      }
    }
    return fragments;
}
```

将其改为接收一个参数condition，condition是一个方法，执行后得到是否符合条件的布尔值。修改这一步的原因是因为在解析子元素时的while判断条件和初始解析时的判断条件不一样。

之后我们修改最初调用parseFragments时的代码，将原来while的判断改成一个方法参数传入。
```javascript
ast.html = parseFragments(() => i < content.length);
```

修改parseElement的内容
```diff
function parseElement() {
    skipWhitespace();
    if (match('<')) {
      eat('<');
      const tagName = readWhileMatching(/[a-z]/);
      const attributes = parseAttributeList();
      eat('>');
      const endTag = `</${tagName}>`;
      const element = {
        type: 'Element',
        name: tagName,
        attributes,
-       children: []
+       children: parseFragments(() => !match(endTag)),
      };
      eat(endTag);
      skipWhitespace();
      return element;
    }
}
```
很明显，从一个标签开始到标签结束的这部分内容，我们把它看成是子标签的内容。

完善generate内traverse对Element的转换
```javascript
function traverse(node, parent) {
    switch(node.type) {
      case 'Element': {
        ...

        node.children.forEach(child => {
          traverse(child, variableName);
        });

        ...
      }
    ...
}
```


往上一章中的App.svelte中添加内容：
```html
<script>
  let count = 0;
  const updateCount = () => {
    count++;
    console.log('update count', count);
  }
</script>

文本内容1
<button on:click={updateCount}>标签内文本</button>
文本内容2
```

`npm run compile`执行看一下
![[test13.gif]]

## prettier
现在我们已经有了基本的Svelte编译思路，然而我们不管是从我们执行`npm run compile`后的app.js还是从控制台中看，编译出来的代码的格式都非常不美观。
![[Pasted image 20240226151117.png]]

一种方式是我们每次在`npm run compile`后，手动地通过vscode的格式化功能来格式化我们app.js的代码，那有没有更便捷的方式呢？答案便是我们可以在代码中引入prettier。

```bash
npm install prettier -D
```

```javascript
import * as fs from "fs";
import { fileURLToPath } from "url";
import { dirname, resolve } from "path";
import * as acorn from "acorn";
import * as escodegen from "escodegen";
import * as prettier from "prettier";
```

修改我们的入口方法
```javascript
async function bootstrap() {
  try {
    const inputPath = resolve(modulePath, "./App.svelte");
    const outputPath = resolve(modulePath, "./app.js");
    const content = fs.readFileSync(inputPath, "utf-8");
    fs.writeFileSync(outputPath, compile(content), "utf-8");
    const compiledContent = fs.readFileSync(outputPath, "utf-8");
    const prettierContent = await prettier.format(compiledContent, {parser: 'babel'});
    fs.writeFileSync(outputPath, prettierContent, "utf-8");
  } catch (e) {
    console.error(e);
  }
}
```
TODO: 为什么要读两遍？

重新执行`npm run compile`看下
![[Pasted image 20240226152624.png]]
之后我们就能清晰地看到经过编译后的js代码长什么样啦。

## 小结