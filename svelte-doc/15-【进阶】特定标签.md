一些特殊的标签，在平时的开发中比较少遇到。但在特定的场合，却又能发挥大用处。

## 调用自身

```
<svelte:self>
```
调用自身。非常容易联想到，凡是涉及到树形结构的组件，都能使用这个标签。
```html
<script>
// App.svelte
  import Folder from "./Folder.svelte";
  let data = [
    {
      name: "1.txt",
    },
    {
      name: "folder1",
      files: [
        {
          name: "2.png",
        },
        {
          name: "folder2",
          files: [
            {
              name: "3.doc",
            },
          ],
        },
      ],
    },
    {
      name: "3.pdf",
    },
  ];
</script>

<Folder {data} name={'Home'}/>
```

```html
<script>
// Folder.svelte
  export let data = [];
  export let name = '';
</script>

<p>{name}</p>
<ul>
  {#each data as item}
    <li>
      {#if item.files && item.files.length}
        <svelte:self data={item.files} name={item.name} />
      {:else}
        {item.name}
      {/if}
    </li>
  {/each}
</ul>

<style>
  ul {
    padding: 0.2em 0 0 0.5em;
    margin: 0 0 0 0.5em;
    list-style: none;
    border-left: 1px solid #eee;
  }

  li {
    padding: 0.2em 0;
  }
</style>
```
![[Pasted image 20240306173440.png]]
使用这个标签时，需要注意终止条件的判断，否则很可能造成无限递归调用。


## 动态渲染

```
<svelte:component>
```

用于动态渲染组件，可以看成是策略模式的简单使用。比如我们要设计一个组件，这个组件有不同的状态，然后我们根据不同的状态展示不同的icon。
正常情况下，我们可能会写出以下代码：
```html
{#if type === 'success'}
{:else if type === 'warning'}
{:else if type === 'error'}
{:else}
{/if}
```
这种面条式的状态判断好处是直观，但一旦我们的状态多起来，代码会变得非常冗长。

看下<svelte:component>的使用：
```html
<script>
  import SuccessIcon from "./icon/SuccessIcon.svelte";
  import InfoIcon from "./icon/InfoIcon.svelte";
  import WarningIcon from "./icon/WarningIcon.svelte";
  import ErrorIcon from "./icon/ErrorIcon.svelte";

  $: icon = {
    success: SuccessIcon,
    info: InfoIcon,
    warning: WarningIcon,
    error: ErrorIcon,
  }[type];


</script>

<svelte:component this={icon} />
```
这是我们的一个Icon组件，能够根据传递的type参数来显示不同的icon。所有状态及对应状态的映射内容收拢在一个对象里，根据状态的不同直接取对应状态的内容返回。
![[Pasted image 20240307104106.png]]


```
<svelte:element>
```

和前一個 `<svelte:component>` 很像，只是 `component` 是自定义的组件，而 `element` 是针对内建的html元素。

TODO動態指定元素的時候不能夠 `bind:value`，也就是下面這樣是不行的:

下面這樣可以，因為他不是動態指定:

```html
<svelte:element this="input" bind:value={text} />
```

不能在動態帶入 [`void`](https://developer.mozilla.org/en-US/docs/Glossary/Void_element) 元素的時候有內容

## window, document, body, head
 <svelte:window>
```
<svelte:window>
```

监听window对象

```
<svelte:document>
```
监听document对象

```
<svelte:body>
```
监听document.body

```
<svelte:head>
```
往`<head>`标签中添加`<script>`、`<link>`、`<title>` 和 `<meta>` 等元素。

这几个标签都只能在代码顶层中进行添加。不像<svelte:self>和<svelte:component>等标签可以在循环判断或条件判断中嵌套添加。
## fragment
```
<svelte:fragment>
```

相当于Vue中的`<template>`和React中的`React.Fragment`、`<></>`标签。

```html
<!-- Child.svelte -->
<div>
  <header>
    <slot name="header">头部</slot>
  </header>
  <main>
    <slot>内容</slot>
  </main>
  <footer>
    <slot name="footer">底部</slot>
  </footer>
</div>

<style>
  footer {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
</style>
```

```html
<script>
 import Child from "./Child.svelte";
</script>

<Child>
  <div slot="footer">
    <div>底部左边</div>
    <div>底部右边</div>
  </div>
</Child>
```

![[Pasted image 20240307105256.png]]

我们原本在组件内容实现了底部内容的flex布局，然而因为我们在外部，需要一个标签来设置`slot="footer"`而导致需要对从外部传的内容进行一层包裹。导致原本期望的flex布局并不生效。一种解决方式是我们在自己外部自己再手动实现flex布局，另一种方式便是使用<svelte:fragment>标签。

```html
<Child>
  <svelte:fragment slot="footer">
    <div>底部左边</div>
    <div>底部右边</div>
  </svelte:fragment>
</Child>
```

![[Pasted image 20240307105653.png]]
可以看到<svelte:fragment>不会被当成实际标签编译展示到页面上。

如何定义自己的标签，可以吗？
https://svelte.dev/docs/custom-elements-api

## 小结
文章只带大家一起体验了较为常用的一些标签，类似<svelte:options>

