
version: 4.2.12
# compiler


# runtime
要了解Svelte的运行时逻辑，可以从它编译后的代码出发。我们在[REPL](https://svelte.dev/repl/hello-world?version=4.2.12)编写一个简易的程序。

```html
<script>
	let count = 0;
	const updateCount = () => {
		count++;
	}
</script>

<button on:click={updateCount}>add count</button> 
<p>count: {count}</p>
{#if count> 2}
	hello svelte!!!
{/if}
```

看下编译后的js代码：
```javascript
/* App.svelte generated by Svelte v4.2.12 */
import {
	SvelteComponent,
	append,
	detach,
	element,
	empty,
	init,
	insert,
	listen,
	noop,
	safe_not_equal,
	set_data,
	space,
	text
} from "svelte/internal";

import "svelte/internal/disclose-version";

function create_if_block(ctx) {
	let t;

	return {
		c() {
			t = text("hello svelte!!!");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

function create_fragment(ctx) {
	let button;
	let t1;
	let p;
	let t2;
	let t3;
	let t4;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*count*/ ctx[0] > 2 && create_if_block(ctx);

	return {
		c() {
			button = element("button");
			button.textContent = "add count";
			t1 = space();
			p = element("p");
			t2 = text("count: ");
			t3 = text(/*count*/ ctx[0]);
			t4 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			insert(target, button, anchor);
			insert(target, t1, anchor);
			insert(target, p, anchor);
			append(p, t2);
			append(p, t3);
			insert(target, t4, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*updateCount*/ ctx[1]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*count*/ 1) set_data(t3, /*count*/ ctx[0]);

			if (/*count*/ ctx[0] > 2) {
				if (if_block) {
					
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(button);
				detach(t1);
				detach(p);
				detach(t4);
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let count = 0;

	const updateCount = () => {
		$$invalidate(0, count++, count);
	};

	return [count, updateCount];
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default App;
```

我们理一下编译后的大题逻辑：
* 首先是建一个`SvelteComponent`类，该类由`svelte/internal`导出。在`SvelteComponent`类实例化时化时调用`init`方法。`init`方法中比较关键的参数有`instance`和`create_fragment`。
* `instance`是一个方法，里面有用于触发响应式更新的方法`$$invalidate`。
* `create_fragment`组件完整的生命周期，包含了创建、挂载、更新和卸载。

我们所关注的运行时逻辑都在源码仓库的`packages/svelte/src/runtime`里。
![[Pasted image 20240319104611.png]]
## SvelteComponent

源码路径：`packages/svelte/src/runtime/internal/Component.js`
```javascript
export class SvelteComponent {
	$$ = undefined;
	$$set = undefined;
	$destroy() {}
	$on(type, callback) {}
	$set(props) {}
}
```
在官网的[Client-side component API](https://svelte.dev/docs/client-side-component-api)中，有介绍这些api的使用，我们集中关注`$$`这个属性，后面大量的数据会挂载到这个属性上。
## init
`init`方法，在组件初始化时执行的唯一方法，由`svelte/internal`导出。
源码路径：`packages/svelte/src/runtime/internal/Component.js

```javascript
export function init(
	component,
	options,
	instance,
	create_fragment,
	not_equal,
	props,
	append_styles = null,
	dirty = [-1]
) {
	const parent_component = current_component;
	set_current_component(component);
	/** @type {import('./private.js').T$$} */
	const $$ = (component.$$ = {
		fragment: null,
		ctx: [],
		// state
		props,
		update: noop,
		not_equal,
		bound: blank_object(),
		// lifecycle
		on_mount: [],
		on_destroy: [],
		on_disconnect: [],
		before_update: [],
		after_update: [],
		context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
		// everything else
		callbacks: blank_object(),
		dirty,
		skip_bound: false,
		root: options.target || parent_component.$$.root
	});

	let ready = false;
	$$.ctx = instance
		? instance(component, options.props || {}, (i, ret, ...rest) => {
				const value = rest.length ? rest[0] : ret;
				if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
					if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
					if (ready) make_dirty(component, i);
				}
				return ret;
		  })
		: [];
	$$.update();
	ready = true;
	run_all($$.before_update);
	$$.fragment = create_fragment ? create_fragment($$.ctx) : false;
	if (options.target) {
		$$.fragment && $$.fragment.c();
		mount_component(component, options.target, options.anchor);
		flush();
	}
	set_current_component(parent_component);
}
```
这里笔者删除了一些无关代码，比如样式的添加，hydrate注水逻辑等。
先看下`init`接收的几个参数：
```javascript
init(
	component,
	options,
	instance,
	create_fragment,
	not_equal,
	props,
	append_styles = null,
	dirty = [-1]
) 
```
- component：组件实例，即组件初始化时传的this
- instance：外部传入的方法，内含数据更新逻辑
- create_fragment：外部传入的方法，组件的生命周期逻辑
- dirty：组件内的数据更新标识

init的逻辑：
- 进入`init`，首先设置当前组件为正在运行的组件，往组件的`$$`属性中挂载大量属性
- 执行`instance`方法，`instance`接收三个参数，第一个参数是组件实例，第三个参数是一个方法，其实它就是`$$invalidate`（待会分析），执行后将返回值挂载到`$$.ctx`。
- 进行更新，`run_all($$.before_update)`在`mount_component`之前，对应了我们在生命周期里了解到的第一次`beforeUpdate`是在`onMount`之前执行的。
- `create_fragment`创建组件的fragment，同时挂载到`$$.fragment`。`mount_component`挂载组件到页面上。
- 执行`flush`方法。
- 执行完这个组件的逻辑后，重置当前组件为父组件。

### `$$invalidate`
`$$invalidate`的逻辑：
- 首先是编译器将我们原来的赋值代码进行了更改，将`count++`转变成`$$invalidate(0, count++, count)`，看下`$$invalidate`的三个参数`(i, ret, ...rest)`：i表示是组件内的第几个变量，ret是表达式，`...rest`是剩余参数
- 首先是进行赋值`($$.ctx[i] = value)`，然后通过`not_equal`判断赋值前后的变量是否改变，如果改变了，通过`make_dirty`标记组件为dirty（非常关键！！！）

### create_fragment
```javascript
function create_fragment(ctx) {
	let button;
	...
	let if_block = /*count*/ ctx[0] > 2 && create_if_block(ctx);

	return {
		c() {
			button = element("button");
			button.textContent = "add count";
			t1 = space();
			p = element("p");
			t2 = text("count: ");
			t3 = text(/*count*/ ctx[0]);
			...
		},
		m(target, anchor) {
			insert(target, button, anchor);
			...
			append(p, t2);
			...

			if (!mounted) {
				dispose = listen(button, "click", /*updateCount*/ ctx[1]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*count*/ 1) set_data(t3, /*count*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) {
				detach(button);
				...
			}
		}
	};
}```
`create_fragment`的逻辑：
- `create_fragment`接收一个参数ctx，我们通过前面知道，这个ctx就是`instance`方法执行后的返回值，ctx是一个数组，包含了数据和用于更新数据的方法，比如：
```javascript
function instance($$self, $$props, $$invalidate) {
	let count = 0;

	const updateCount = () => {
		$$invalidate(0, count++, count);
	};

	return [count, updateCount];
}
```
- `create_fragment`方法返回一个对象，可以把这个对象理解为是组件的生命周期对象，内部的`c`、`m`、`p`、`d`对应了创建、挂载、更新和卸载。
- 在创建时，会调用封装好的`element`、`space`、`text`等方法；在挂在时调用`insert`、`append`等方法；在更新时，通过dirty数组中的值进行位运算，判断是否需要更新数据，还记得我们前面章节学习到的位运算的知识吗，在Svelte源码中，凡是涉及到dirty的地方，位运算无处不在；在卸载时调用`detach`等方法。

## mount_component
源码路径：`packages/svelte/src/runtime/internal/Component.js
```javascript
export function mount_component(component, target, anchor) {
	const { fragment, after_update } = component.$$;
	fragment && fragment.m(target, anchor);
	// onMount happens before the initial afterUpdate
	add_render_callback(() => {
		const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);

		if (component.$$.on_destroy) {
			component.$$.on_destroy.push(...new_on_destroy);
		} else {
			run_all(new_on_destroy);
		}
		component.$$.on_mount = [];
	});
	after_update.forEach(add_render_callback);
}
```