  

每个组件从创建开始，到销毁结束这个过程，都有一个生命周期

每个组件都有从创建到销毁的过程，这个过程被称为生命周期

  

生命周期函数就是在生命周期的某个阶段运行的代码

  
  

各个主流框架都有，它是一种 Hook 钩子函数，所谓钩子，实际上是一种回调，它提前声明，并将在适当的时机被自动调用

  Svelte的生命周期钩子有：
  * onMount
  * beforeUpdate
  * afterUpdate
  * onDestroy
  * tick
  

在svelte中生命周期函数只能在组件初始化时编写，以便将回调绑定到组件的实例，不可以将生命周期函数放在例如异步的 setTimeout 中。

如果你使用服务端渲染（SSR），除了 onDestroy，其余生命周期函数不会在 SSR 运行期间执行

  

## onMount

在组件挂载到DOM后立即执行的回调。
```
onMount(callback: () => void)

onMount(callback: () => () => void)
```

如果`onMount`返回一个函数，则在卸载组件时调用该函数。

我们可以看下源码，在Svelte项目的`packages/svelte/src/runtime/internal/Component.js`文件内：
```javascript
/** @returns {void} */
export function mount_component(component, target, anchor) {
	const { fragment, after_update } = component.$$;
	fragment && fragment.m(target, anchor);
	// onMount happens before the initial afterUpdate
	add_render_callback(() => {
		const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
		// if the component was destroyed immediately
		// it will update the `$$.on_destroy` reference to `null`.
		// the destructured on_destroy may still reference to the old array
		if (component.$$.on_destroy) {
			component.$$.on_destroy.push(...new_on_destroy);
		} else {
			// Edge case - component was destroyed immediately,
			// most likely as a result of a binding initialising
			run_all(new_on_destroy);
		}
		component.$$.on_mount = [];
	});
	after_update.forEach(add_render_callback);
}
```
我们可以看到，会执行onMount的方法后拿到一个值，接着会判断组件内有没有声明`onDestroy`生命周期钩子，有则添加到onDestroy数组中，在执行onDestroy后执行，没有则直接执行这个返回值。在React的`useEffect`hook中，有相同的功能。

```javascript
useEffect(() => {
	return () => {}
}, []);
```

```html
<script>
  import { onMount } from 'svelte';

  onMount(() => {
    console.log('child mount');
    return () => {
      console.log('child destroy 1');
    }
  })
</script>

<div>child</div>
```

```html
<script>
  import Child from './Child.svelte';
	let count = 0;
	
	const updateCount = () => {
		count++;
	}
</script>


<button on:click={updateCount}>add</button>
{#if count == 0}
<Child />
{/if}
```

执行child mount -> child destroy 1

```html
<script>
  import { onMount, onDestroy } from 'svelte';

  onMount(() => {
    console.log('child mount');
    return () => {
      console.log('child destroy 1');
    }
  })

  onDestroy(() => {
    console.log('child destroy 2');
  })
</script>

<div>child</div>
```
执行child mount -> child destroy 2 -> child destroy 1


对于兄弟组件，onMount 会根据组件调用的顺序，从上往下执行。而对于父子组件，当子组件的 onMount 执行完毕之后，才会执行父组件的 onMount，也就是从内到外。
```html
<script>
	import { onMount } from 'svelte';
	import Child from './Child.svelte';
	import Child2 from './Child2.svelte';
	
	onMount(() => {
		console.log('fahter mount');
	})
</script>

<Child />
<Child2 />
```
我们定义三个组件：一个父组件，两个子组件。在三个组件内分别调用onMount。执行后，我们能看到child mount 1 -> child mount 2 -> father mount

## beforeUpdate

```
beforeUpdate(callback: () => void)
```

给所有state变更安排一个回调函数运行在 component渲染之前,首次回调运行在 `onMount`初始化之前


```html
<script>
	import { beforeUpdate } from 'svelte';

	let count = 0;
	let str = '';
	
	const updateData = () => {
		count++;
		setTimeout(() => {
			str += 's';
		}, 1000);
	}

	beforeUpdate(() => {
		console.log('before update', count, str);
	})
</script>

<button on:click={updateData}>update</button>
<span>{count}</span><span>{str}</span>
```
加载页面后，我们会首先看到控制台打印出before update 0。点击按钮更新，看到打印出before update 1，1s后看到打印出before update 1 s。
![[Pasted image 20240219165540.png]]
  
需要注意的是，如果组件中同时存在beforeUpdate与onMount，首次beforeUpdate回调会在 onMount之前执行。如果我们在上述代码中调用onMount钩子，然后执行相同步骤，则看到：
![[Pasted image 20240219165857.png]]

## afterUpdate

在组件渲染之后执行的回调
```
afterUpdate(callback: () => void)
```


对于兄弟组件，beforeUpdate 和 afterUpdate 依然是按照组件调用的顺序，从上往下执行

  

而对于父子组件，会先执行父组件的 beforeUpdate，然后执行子组件的 beforeUpdate


当子组件的 beforeUpdate 执行完毕之后，再执行父组件的 afterUpdate，最后执行子组件的 afterUpdate

```html
<script>
	import { onMount, onDestroy, beforeUpdate, afterUpdate } from 'svelte';
	import Child from './Chapter00_Child.svelte';
	import Child2 from './Chapter00_Child2.svelte';
	let count = 0;
	
	const updateCount = () => {
		count++;
	}

	beforeUpdate(() => {
		console.log('fater beforeupdate');
	});

	onMount(() => {
		console.log('father mount');
	});

	afterUpdate(() => {
		console.log('father afterupdate');
	});

	onDestroy(() => {
		console.log('father destroy');
	});
</script>

<button on:click={updateCount}>add</button>
{#if count <= 1}
	<Child count={count} />
	<Child2 count={count} />
{/if}

```

```html
<script>
  import { onMount, onDestroy, beforeUpdate, afterUpdate } from 'svelte';

  export let count;

  beforeUpdate(() => {
    console.log('child beforeupdate 1')
  });

  onMount(() => {
    console.log('child mount 1');
  });

  afterUpdate(() => {
    console.log('child afterupdate 1');
  });

  onDestroy(() => {
    console.log('child destroy 1');
  });
</script>

<div>child</div>
{count}
```

在初次执行时
![[Pasted image 20240219172137.png]]

点击按钮更新后
![[Pasted image 20240219172157.png]]

举例：聊天界面之滚动？

  

## onDestroy

在组件卸载后运行的回调。
```

onDestroy(callback: () => void)

```

  
兄弟组件之间的 onDestroy 依然是根据调用顺序从上往下

  

而父子组件则是从外到内，先执行父组件的 onDestroy，再执行子组件的 onDestroy

onMount 返回的函数会在组件销毁的时候执行，这个函数会在 onDestroy 之后执行。

## tick

  

```

promise: Promise = tick()

```

返回一个Promise，在任何一个state状态发生变化时立即resolve

在Svelte中，当改变一个state状态时，不会立即更新DOM，而是会等到下一个微任务时更新，在等待期间会持续监听是否有其他state状态改变，然后在这个微任务中统一更新DOM，这样可以减少一些无用功，让浏览器更有效地批量处理这些事情

  

开发过程中可能会遇到这种问题：组件中的某个状态更新了，但 DOM 没有更新

  

这时就可以使用 tick 函数，它会返回一个 Promise，当组件的状态更新之后，会触发这个 Promise 的 resolves

  

是不是和vue的nextTick一样？

  
  
  

虽然在组件初始化期间调用生命周期函数很重要，但是从何处调用它们都无关紧要。

  

只要对应的生命周期函数可以在组件被初始化的时候执行到即可

```

import { onDestroy } from 'svelte';

  

export function onInterval(callback, milliseconds) {

const interval = setInterval(callback, milliseconds);

  

onDestroy(() => clearInterval(interval));

}

  

```

```html

<script>

// onDestory方法并没有被定义在组件中，而是被定义在了工具文件中

import { onInterval } from './utils.js';

  

let seconds = 0;

onInterval(() => seconds += 1, 1000);

</script>

<p>
The page has been open for
{seconds} {seconds === 1 ? 'second' : 'seconds'}
</p>

  

```


## 小结

在这一章，我们学习了Svelte的几个生命钩子以及它们在父子组件中的调用顺序。