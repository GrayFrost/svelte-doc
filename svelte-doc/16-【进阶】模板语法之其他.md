## await

在列表展示时，为了提升用户体验，我们在数据请求的过程中，往往会使用一些loading toast来提示用户我们正在请求，等到请求完成后便会隐藏loading提示而展示我们请求成功的数据。

我们Svelte有自己的Suspense！

```
{#await expression}...{:then name}...{:catch name}...{/await}
```

  

react suspense

  

vue3 suspense

```html
<script>
 const myFetch = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      let data = [{
        value: 'hello'
      }, {
        value: 'svelte'
      }];
      resolve(data);
    }, 2000)
  })
 }
</script>

{#await myFetch()}
  <div>loading...</div>
{:then data} 
  {#each data as item}
    <div>{item.value}</div>
  {/each}
{/await}
```

![[test60.gif]]

```html
<script>
 const myFetch = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const error = new Error('接口出错！');
      reject(error);
    }, 2000)
  })
 }
</script>

{#await myFetch()}
  <div>loading...</div>
{:then data} 
  {#each data as item}
    <div>{item.value}</div>
  {/each}
{:catch error}
  <div>页面出错：{error.message}</div>
{/await}
```

![[test61.gif]]
## html

```javascript
{@html expression}
```

需要对html内容进行转义

  

Svelte不会在注入HTML之前转义表达式。如果数据来源不受信任，则必须对其进行转义，否则将用户暴露于XSS漏洞之中。

举个例子：
```html
<script>
  const htmlContent = '<img src="http://www.xxx.com" onerror="alert(1)">';
</script>

{@html htmlContent}
```


![Alt text](./img/16-1.png)

![Alt text](./img/16-2.png)

  

过滤 xss防御库

https://www.npmjs.com/package/xss

https://github.com/cure53/DOMPurify


```html
<script>
  import xss from "xss";

  const htmlContent = '<img src="http://www.xxx.com" onerror="alert(1)">';

  const filterContent = xss(htmlContent);
</script>

{@html filterContent}
```

![Alt text](./img/16-3.png)

## key

```
{#key expression}
```

> Key blocks destroy and recreate their contents when the value of an expression changes.This is useful if you want an element to play its transition whenever a value changes instead of only when the element enters or leaves the DOM.

当我们想看到一个元素因为状态变化而产生渐变效果时，我们可以用上这个语法。

```javascript

<script>

import { fly } from 'svelte/transition';

let data = [{ id: 0, value: Math.floor(Math.random() * 100) }];

  

function add() {

const randomIndex = Math.round(Math.random() * data.length);

data = [

...data.slice(0, randomIndex),

{ id: data.length, value: Math.floor(Math.random() * 100) },

...data.slice(randomIndex)

];

}

function remove() {

const randomIndex = Math.floor(Math.random() * data.length);

data = [

...data.slice(0, randomIndex),

...data.slice(randomIndex + 1)

];

}

</script>

  

<button on:click={add}>Randomly Add</button>

<button on:click={remove}>Randomly Remove</button>

  

{#each data as item (item.id)}

<div transition:fly={{y: 10}}>{ item.id } { item.value }</div>

{/each}

```

可以通过渐变的块得知哪些被复用，哪些被删除。todo 重写

  
  

```html

<script>

import { fly } from 'svelte/transition';

  

let number = 0;

</script>

  

<div>

The number is:

{#key number}

<span style="display: inline-block" in:fly={{ y: -20 }}>

{number}

</span>

{/key}

</div>

<br />

<button

on:click={() => {

number += 1;

}}

>

Increment

</button>

  

```

 说实话，笔者认为这个名字存在很大的误导性。 

```html
<script>
  import { slide } from "svelte/transition";

  let second = 60;

  let timer;

  const startCountDown = () => {
    stopCountDown();
    timer = setInterval(() => {
      if (second <= 0 && timer) {
        clearInterval(timer);
        return;
      }
      second--;
    }, 1000);
  };

  const stopCountDown = () => {
    if (timer) {
      clearInterval(timer);
    }
  };

  $: strArr = String(second).split("");
</script>

<button on:click={startCountDown}>开始倒计时</button>
<button on:click={stopCountDown}>停止倒计时</button>

<div class="num-list">
  {#each strArr as item}
    {#key item}
      <div class="num" in:slide={{duration: 1000}}>
        {item}
      </div>
    {/key}
  {/each}
</div>

<style>
  .num-list {
    display: flex;
  }
  .num {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100px;
    height: 150px;
    background: black;
    border-radius: 12px;
    color: white;
    font-size: 48px;
    margin-right: 10px;
  }
</style>
```

![[test62.gif]]
在这个例子中，我们针对每个变动的数字，添加了slide的过渡效果。当数字变化时，过渡效果便会生效，数字不变化时，则没有过渡效果。
## debug
```

{@debug}

```

打开控制台时，会出现调试断点，且当我们改变变量的值时，debug会再次被唤醒

## 小结
同样`{@const}`没有讲解，留给读者自行探究