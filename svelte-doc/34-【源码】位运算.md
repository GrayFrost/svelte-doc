记得调整为自己的话来描述！！！

JS 中所有的数字都是符合 `IEEE-754` 标准的 `64` 位双精度浮点类型。而所有的位运算都只会保留 `32` 结果的整数。

```
component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31))
```

**`(i / 31) | 0`** ：这里是用数组下标 `i` 属于 31，然后向下取整（任何整数数字和 `| 0` 的结果都是其本身，位运算有向下取整的功效）。
 **`(1 << (i % 31))`** ：用 `i` 对 `31` 取模，然后做左移操作

dirty 是个数组类型，存放了多个 `32` 位整数，整数中的每个 `bit` 表示换算成 `instance` 数组下标的变量是否发生变更

为了方便理解，我们用四位整数

```
[1000] => [8] 表示 instance 中的第一个变量是 dirty。
[1001] => [9] 表示 instance 中的第一个变量和第四个变量是 dirty。
[1000, 0100] => [9, 4] 表示 instance 中的第一个变量和第六个变量是 dirty。
```

有个约定，如果 dirty 第一个数字存储的是 `-1` 表示当前组件是干净的

```
$$.dirty = [-1];
```

原码、反码和补码

常见的二进制编码方式

原码：最高位表示正负、其他位表示数值。阅读友好，缺点是对运算不友好

```
// +11
00001011

// -11 只有第一位不一样
10001011
```

**反码** 是在原码的基础上，保留符号位，负数的数值位全部“取反”。a + -a 会等于 `11111111` (-0)。遗留的问题当然是，这样的编码产生了 `0` 和 `-0`。同一个数字有两种表示势必会产生不必要的判断。于是补码出现了

**补码** 是在反码的基础上继续优化，符号位仍然不变，负数数值在原来的基础上 `+1`

```
// +11
00001011

// 反码中的 -11
11110100

// 补码的 -11
11110101
```

由于加 `1`，a + -a 相加将会产生进位。

```
  00001011 (11)
+ 11110101 (-11)
________________
 100000000

```

多出来的一位会因为溢出被忽略掉，于是 `a + -a = 0` 任然成立。这样设计之后 `-0` 就不存在了。`00000000` 取反之后再加一 仍然是 `00000000`。`10000000` 任被用来表示负数，所以在补码的设计里面，负数比正式多了一位。在现代计算机系统中，提到位运算时都是使用补码。

## 位运算

做位运算时所有的运算数以及运算结果只会保留 32 位的整数。

为方便演示，例子使用8位进行演示

#### 按位与 &

两个位都是 1 时，结果为为 1，否则为 0

```
  00001011 (11)
& 00001001 (9)
__________
  00001001 (9)

```

按位与的应用：react源码中的应用？

按位或 |

两个位都是 0 时，结果为为 0，否则为 1

应用场景？

#### 按位异或 ^

两个位都是 0 或者都是 1 时，结果为为 0，否则为 1。任何数和自身异或结果都为零，和零异或结果都是其本身。

应用场景？

#### 按位非 ~

按位原来是 1 变为 0，0 变为 1，结果按补码形式出现。

应用场景？

#### 左移 <<

把数值的二进制表示向左移位，移除的位会被遗弃，末尾补 0

#### 右移 >>

把数值的二进制表示向右移位，末尾的位会被遗弃，前面的位会按符号位来补，符号位是 1，补 1，符号位是 0，补 0。

#### 无符号右移 >>>

无符号右移，顾名思义就是右移的时候，不考虑符号位，前面统统补 `0`。

场景

左移：乘以2

右移：除以2

判断奇偶性：通过和1的与运算检查最低位，判断数值的奇偶性

```
let num = 7;
let isOdd = num & 1; // 结果为1，奇数
```

### gpt的解释

* `component.$$.dirty[(i / 31) | 0]`：这是在访问一个数组 `component.$$.dirty`的特定索引。索引是通过将 `i`除以31并向下取整（`| 0`操作符）得到的。这样做的原因是JavaScript的位操作符只能处理32位整数，所以我们将位图分割成32位的块。
* `|= (1 << (i % 31))`：这是一个位操作，用于设置位图中的特定位。`1 << (i % 31)`会创建一个只有第 `(i % 31)`位为1的数，其余位都为0。然后，`|=`操作符将这个数与 `component.$$.dirty[(i / 31) | 0]`进行位或操作，这样就可以将第 `(i % 31)`位设置为1，而不改变其他位。

总的来说，这段代码的作用是在 `component.$$.dirty`的位图中，将第 `i`位设置为1。

为什么要用 `|=运算而不直接赋值？`

因为如果出现大于32位的变量的时候，此时赋值便会出错了。

就是判断组件内的变量是否改变，如果出现一个变量，并且在html模块中被引用,则类似如下

流程，

如果有数据更新，调用

```
$$invalidate(0, count++, count);
```

这里的第一个参数便是i。这个方法便是下面方法的第三个参数

```javascript

instance(component, options.props || {}, (i, ret, ...rest) => {
  const value = rest.length ? rest[0] : ret;
  if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
    if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
    if (ready) make_dirty(component, i);
  }
  return ret;
})
```
如果发现not_equal，会调用make_dirty
```
function make_dirty(component, i) {
	if (component.$$.dirty[0] === -1) {
		dirty_components.push(component);
		schedule_update();
		component.$$.dirty.fill(0);
	}
	component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
}
```
如果我们更新count变量，此时`component.$$.dirty[0]`上存储的值便是`0 | 1`后的值1
这里了会调用schedule_update()，在里面经过调度，会执行update
```
function update($$) {
	if ($$.fragment !== null) {
		$$.update();
		run_all($$.before_update);
		const dirty = $$.dirty;
		$$.dirty = [-1];
		$$.fragment && $$.fragment.p($$.ctx, dirty);
		$$.after_update.forEach(add_render_callback);
	}
}
```
最终会执行create_frament里的p方法，我们看编译出来的p方法
```
if (dirty & /*count*/ 1) set_data(t4, /*count*/ ctx[0]);
```
此时dirty是1，1 & 1还是1。一个变量看不出来，我们多设两个变量。


## 参考

https://segmentfault.com/a/1190000040065124

https://lihautan.com/compile-svelte-in-your-head-part-2/

https://juejin.cn/post/6942291040044843038
