create_fragment

instance

脏检测 make_dirty

[官方Example](https://svelte.dev/examples/hello-world#hello-world)

```html
<script>
	let name = 'world';
</script>

<h1>Hello {name}!</h1>
```

```javascript
/* App.svelte generated by Svelte v4.2.8 */
import {
	SvelteComponent,
	detach,
	element,
	init,
	insert,
	noop,
	safe_not_equal
} from "svelte/internal";

import "svelte/internal/disclose-version";

function create_fragment(ctx) {
	let h1;

	return {
		c() {
			h1 = element("h1");
			h1.textContent = `Hello ${name}!`;
		},
		m(target, anchor) {
			insert(target, h1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(h1);
			}
		}
	};
}

let name = 'world';

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment, safe_not_equal, {});
	}
}

export default App;
```

```javascript
interface Fragment {
  key: string | null;
  first: null;
  /* create  */ c: () => void;
  /* claim   */ l: (nodes: any) => void;
  /* hydrate */ h: () => void;
  /* mount   */ m: (target: HTMLElement, anchor: any) => void;
  /* update  */ p: (ctx: any, dirty: any) => void;
  /* measure */ r: () => void;
  /* fix     */ f: () => void;
  /* animate */ a: () => void;
  /* intro   */ i: (local: any) => void;
  /* outro   */ o: (local: any) => void;
  /* destroy */ d: (detaching: 0 | 1) => void;
}

```

编译出来的结果就是有一个初始化函数，叫 create_fragment，它是用于 dom 的初始挂载。create_fragment 的过程还包含有 `c,m,p,i,o,d`等特殊名称的函数，这些函数并非编译混淆，而是 Fragment 内部的生命周期缩写

SvelteComponent 则是包含了 svelte 组件内置的属性和生命周期，它们与 Fragment 的属性和生命周期是息息相关，SvelteComponent 是依赖于 Fragment，组件的变化会触发 Fragment 的变化

svelte 官方的 webpack 插件[svelte-loader](https://github.com/sveltejs/svelte-loader)和 rollup 插件[rollup-plugin-svelte](https://github.com/sveltejs/rollup-plugin-svelte)的主要都是基于 svelte.compile，这个编译器主要分为两部分 parse 和 compile，parse 是解析的过程，解析 script 和 style 等 tag 标签以及 each 和 ifelse 等 mustache 模版语法。compile 则是包含了 parse 的动作，将解析出来的 ast 语法树转换为可执行的代码

在 svelte 源码里，使用了 acorn 将 javascript 编译成 ast 树，然后对 javascript 的语义解释过程做了额外的工作：

* 编译赋值语句时，除了生成对应的赋值逻辑，额外生成数据更新逻辑代码
* 编译变量声明时，变量被编译成上下文数组
* 编译模板时，标记依赖，并对每个变量引用生成更新逻辑

svelte 组件使用create, mount, patch, destroy 这四个方法实现对 DOM 视图的操作。

* create 负责组件dom的创建
* mount 负责将 dom 挂载到对应的父节点上
* patch 负责根据数据的变化更新 dom
* destroy 负责销毁对应的 dom
* 首先解析 svelte 模板并生成模板 AST
* 然后遍历模板 AST
* * 如果碰到普通的 html tag 或者文本，输出 dom 创建语句（dom.createElement)
  * 如果碰到变量
  * * 转换为上下文引用方式并输出取值语句（如： name 被生成为 ctx[/** name */0])
    * 在 patch 函数中生成对应的更新语句
  * 如果碰到 if 模板
  * * 获取 condition 语句，输出选择函数 select_block （子模板选择器）
    * 获取 condition 为 true 的模板片段，输出 if_block 子模板构建函数
    * 获取 condition 为 false 的模板片段，输出 else_block 子模板构建函数
  * 如果碰到 each 模板
  * * 获取循环模板片段，生成块构建函数 create_each_block
    * 根据循环内变量引用，生成循环实例上下文获取 get_each_block_context
* 生成 key获取函数 get_key
* 生成基于key更新列表的patch逻辑函数 update_keyed_each

视图更新时通过patch函数来完成的。

```javascript
function patch(ctx, [dirty]) {
  if (dirty & /*name*/ 1) set_data(t1, /*name*/ ctx[0]);
  if (dirty & /*age*/ 2) set_data(t4, /*age*/ ctx[1]);
  if (dirty & /*school*/ 4) set_data(t6, /*school*/ ctx[2]);
}
```

通过 dirty 位检查变量是否发生更新，如果发生更新调用 dom 操作函数对 dom 进行局部更新。上面例子的 set_data 函数作用是给 dom 设置 innerText。根据数据更新的视图位置的不同，还会有 set_props之类的更新 dom 属性的函数等

每个数据的赋值语句，svelte都会生成对$$invalidate的调用，invalidate的调用主要做的是对某个改动的变量进行标记，然后在微任务中调用patch函数，根据变量改动的脏标记进行局部更新

https://astexplorer.net/



* instance 方法：可以理解为 instance方法是 svelte 组件的构造器。写在 script 里的代码，会被生成在 instance 方法里。每个组件实例都会调用一次形成自己的闭包，从而隔离各自的数据，通过 instance 方法返回的数组就是上下文。代码中的赋值语句，会被生成为数据更新逻辑。变量定义会被收集生成上下文数组。
* 上下文：每个 svelte 组件都会有自己的上下文，上下文存储的就是 script 标签内定义的变量的值。svelte 会为每个组件实例内定义的数据生成上下文，按照变量的声明顺序保存在一个名为 ctx 数组内
