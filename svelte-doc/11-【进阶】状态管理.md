当业务逻辑简单时，我们可以把所有变量都放在各自的组件或页面内。然而真实的开发情况是，我们的业务逻辑会越来越复杂，页面所承载的数据，亦或者页面与页面之间公用的状态等会变得越来越庞大。此时如何处理和维护系统的状态将变得尤为关键。

## svelte/store

React 的 Redux，或者 Vue 的 Vuex， Pinia。而Svelte内部直接提供了`svelte/store`来管理状态。

svelte/store导出了三个方法`writable`、`readable`和`derived`。
```javascript
// store.js
import { writable } from 'svelte/store';
export const count = writable(0);
```

```html
<script>
// App.svelte
  import { count } from './store';

  count.subscribe(c => {
    console.log('最新值：', c);
  })

  const onSet = () => {
    count.set(1);
  }

  const onUpdate = () => {
    count.update(c => c + 1);
  }
</script>


<button on:click={onSet}>置为1</button>
<button on:click={onUpdate}>加1</button>
```

![[test28.gif]]

我们在页面中要如何使用writable state？如果我们直接写`{count}`，
![[Pasted image 20240301105656.png]]
很明显，count已经不是简单的变量。尝试把count`$: console.log('count', count)`打印出来。
![[Pasted image 20240301110736.png]]
此时的count是一个对象，内部有set、subscribe、update方法。

一个取巧的方式是，我们在页面内部声明一个变量，然后在subscribe监听到状态变化时，将最新的更改赋值给我们声明的变量。
```html
<script>
let _count;

const unsubscribe = count.subscribe(c => {
  _count = c;
});
</script>

{_count}
```




  
取消订阅
仍旧以上面例子为例，我们把原本在App.svelte的逻辑移入到Child.svelte，然后引入Child.svelte
```html
<script>
  import Child from './Child.svelte';
  import { count } from './store';
  
  let countValue = 0;

  count.subscribe(value => {
    countValue = value;
  })

  const onUpdate = () => {
    count.update(c => c + 1);
  }
</script>

{#if countValue < 5}
  <Child />
{/if}

<button on:click={onUpdate}>father update</button>
```

![[test29.gif]]

可以看到App.svelte和Child.svelte内都能更新count。而当Child.svelte因为不满足if条件而被销毁之后，内部的subscribe仍在执行，这显然是不符合期望的。试想一下，如果我们有成千上万个有显示隐藏功能的组件都进行了subsribe。每当这些组件销毁时，这些监听事件仍被保留，久而久之，将会出现内存溢出的风险。因此，每当我们执行了subscribe后，记得在合适的时机进行销毁。
subscribe执行后返回一个方法，这个方法变用来取消订阅。

修改Child.svelte的代码
```html
<script>
  import { onDestroy } from 'svelte';
  import { count } from './store';

  const unsubscribe = count.subscribe(c => {
    console.log('最新值：', c);
  })

  const onSet = () => {
    count.set(1);
  }

  const onUpdate = () => {
    count.update(c => c + 1);
  }

  onDestroy(unsubscribe);
</script>


<button on:click={onSet}>置为1</button>
<button on:click={onUpdate}>加1</button>
```
  ![[test30.gif]]
  

### 可写状态 writable

### 可读状态 readable

### 状态继承 derived
store derived 相当于selector
  

自定义store

当我们需要知道 `count` 当前值的时候，应该使用 `update`，它会将当前值传递到回调函数供你使用；如果无需知道，则使用 `set`


## 自动订阅

每当引用 store时，都可以通过在其前面加上 `$`字符来访问其在component内部的值，这会使Svelte自动声明前缀变量，并设置将在适当时取消store subscription

## 自定义store

只要一个对象正确地实现了 subscribe 方法，它即是一个 store。除了之外，怎样都行。

## 第三方库

### rxjs


### zustand


### xstate


## 小结
