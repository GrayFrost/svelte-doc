## 数据绑定

数据是页面展示中最重要的一环，在本章，我们将学习数据的声明与更新，以及与数据相关的一些细节。
在React中，我们通过 `this.state`来对变量进行声明存储，亦或是通过 `useState`来操作；在Vue中，我们可以把数据放到 `data()`方法的返回值里，亦或者使用 `ref`、`reactive`来声明变量；而在Svelte中，我们则直接在script标签中正常声明，然后再html标签里使用 `{}`来包裹变量。

### 直接声明

```html
<script>
  let count = 0;
</script>

<div>count: {count}</div>
```

### 属性里使用

除了在标签内容里显示，我们可以在标签属性里进行操作变量，比如我们常需要判断动态的样式class。

```html
<script>
  let tab = 'hello'
</script>

<span class={tab === 'hello' ? 'active' : ''}>color text</span>

<style>
  .active {
    color: blue;
  }
</style>
```

在svelte中，active的class还有缩写，我们在介绍样式的章节会继续说明。

### 双向绑定
双向绑定指的是：当我们使用的数据更新时，依赖数据的页面视图也随之更新；而当页面视图发生变化时，数据也会自动更新。这里比较关键的一点在于后半段，页面视图发生变化时的数据自动更新。

在vue中，我们通过 `v-model`实现双向绑定，聪明的你可能会想，既然Svelte操作数据这么方便，那我直接写下这一段代码，那Svelte便能帮我们处理双向绑定了。

```html
<script>
  let str = ''

</script>

<div>
  <input type="text" value={str} />
  <span>input value: {str}</span>
</div>
```

很遗憾，上述代码并没有帮我们处理双向绑定，如果我们想要做双向绑定，需要按下列写法：

```html
<script>
  let str = ''

</script>

<div>
  <input type="text" bind:value={str} />
  <span>input value: {str}</span>
</div>
```

注意到区别了吗？没错，我们需要使用使用到 `bind`。bind除了做双向绑定外，还有其他用处，后面的章节我们会继续遇到这个指令。

#### form组件的双向绑定
在表单组件中，双向绑定较为常见，当然我们也可以自定义能够双向绑定的组件。

```html
<script>
  let value = '';
</script>

<input type="text" value={value} />
<p>value: {value}</p>
```

如果我们按照vue的逻辑直接写出上述代码，会发现当我们在输入框内填写内容时，页面上并没有跟随输出。

要实现双向的数据绑定，需要用到bind指令。
```html
<script>
  let value = '';
</script>

<input type="text" bind:value={value} />
```

### 数据的更新

我们在上面只演示了如何声明和使用变量，但变量最为关键的特性便是——“变”，我们要如何更新声明的变量呢？
其实也是很简单，就像普通的操作一样。

```html
<script>
  let count = 0;

  const updateCount = () => {
    if (count >= 5) {
      return;
    }
    count++;
    setTimeout(() => {
      updateCount();
    }, 1000);
  }

  updateCount();
</script>

<span>count: {count}</span>
```

在上述代码中，笔者声明了一个定时更新的方法，如果你执行上述代码，便能看到count在页面中按秒更新。

### 数组的更新

如果你使用过Vue，那你一定知道在Vue中，对于数组的更新需要一些骚操作。那在Svelte中呢?

在svelte中，使用 `.push()`和 `.splice()`和这样的数组方法不会自动触发更新，如何更新？

在官网里，最开头的一句话已经点出了关键问题：“赋值语句”

## on:*事件名*

每个框架都有自己独特的事件监听的写法，那在Svelte中，按照以下格式进行事件监听的绑定。

```
on:eventname|modifiers={handler}
```

eventname是事件名，比如我们常用的 `click`、`keydown`等等

modifiers修饰符有以下几种：

* `preventDefault` ：在程序运行之前调用 `event.preventDefault()`
* `stopPropagation` ：调用 `event.stopPropagation()`, 防止事件到达下一个标签
* `passive` ：改善了 touch/wheel 事件的滚动表现（Svelte会在合适的地方自动加上它）
* `capture`：表示在 *capture*阶段而不是*bubbling*触发其程序
* `once`

我们现在把数据声明和事件监听绑定起来：

```html
<script>
  let count = 0;

  const updateCount = () => {
    count++;
  }
</script>

<div>
  count: {count}
  <button on:click={updateCount}>+1</button>
</div>
```

笔者再举个例子：

```html
<script>
  let count = 0;

  const sayHello = () => {
    console.log('hello');
  }

  const updateCount = () => {
    count++;
  }
</script>

<div on:click={sayHello}>
  count: {count}
  <button on:click={updateCount}>+1</button>
</div>
```

此时如果我们点击button，那在控制台便会看到hello字符串也在打印出来。
想要阻止事件冒泡，一种方式是在监听的方法里设置 `stopPropagation`

```javascript
const updateCount = (event) => {
  event.stopPropagation();
  count++;
}
```

另一种方式就是使用刚才我们介绍的修饰符，这样我们就不用在我们的业务代码里处理冒泡逻辑。

```html
<button on:click|stopPropagation={updateCount}>+1</button>
```

支持链式调用

内联的方式声明事件处理

```
<div on:mousemove="{e => m = { x: e.clientX, y: e.clientY }}">
  The mouse position is {m.x} x {m.y}
</div>
```

双向绑定

input[type=text]
input[type=number|range]
input[type=checkbox]
textarea
select

## 小结

这一章我们了解了如何在svelte文件中声明数据和更新数据，同时了解了如何在svelte文件中使用自定义函数。
