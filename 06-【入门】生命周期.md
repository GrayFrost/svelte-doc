
每个组件从创建开始，到销毁结束这个过程，都有一个生命周期
每个组件都有从创建到销毁的过程，这个过程被称为生命周期

生命周期函数就是在生命周期的某个阶段运行的代码


各个主流框架都有，它是一种 Hook 钩子函数，所谓钩子，实际上是一种回调，它提前声明，并将在适当的时机被自动调用


在svelte中生命周期函数只能在组件初始化时编写，以便将回调绑定到组件的实例，不可以将生命周期函数放在例如异步的 setTimeout 中。
如果你使用服务端渲染（SSR），除了 onDestroy，其余生命周期函数不会在 SSR 运行期间执行

## onMount

```
onMount(callback: () => void)
onMount(callback: () => () => void)
```

将component挂载到DOM后立即执行的回调。如果 `onMount`返回一个函数，则在卸载 component 时调用该函数。

类似于useEffect中的返回值

对于兄弟组件，onMount 会根据组件调用的顺序，从上往下执行

而对于父子组件，当子组件的 onMount 执行完毕之后，才会执行父组件的 onMount，也就是从内到外

## beforeUpdate

```
beforeUpdate(callback: () => void)
```

给所有state变更安排一个回调函数运行在 component渲染之前,首次回调运行在 `onMount`初始化之前

还有一点需要注意，如果组件中同时存在 beforeUpdate 与 onMount，首次 beforeUpdate 回调会在 onMount 之前

每次渲染之前运行。首次运行是在组件mounted之前，因此需要在读取DOM之前，检查是否存在

## afterUpdate

```
afterUpdate(callback: () => void)
```

在component渲染之后
每次渲染之后运行

对于兄弟组件，beforeUpdate 和 afterUpdate 依然是按照组件调用的顺序，从上往下执行

而对于父子组件，会先执行父组件的 beforeUpdate，然后执行子组件的 beforeUpdate

当子组件的 beforeUpdate 执行完毕之后，再执行父组件的 afterUpdate，最后执行子组件的 afterUpdate

举例：聊天界面之滚动？

## onDestroy

```
onDestroy(callback: () => void)
```

component卸载后运行的回调
在组件销毁时运行

兄弟组件之间的 onDestroy 依然是根据调用顺序从上往下

而父子组件则是从外到内，先执行父组件的 onDestroy，再执行子组件的 onDestroy
onMount 返回的函数会在组件销毁的时候执行，这个函数会在 onDestroy 之后执行

常见用法，清除一开始定义的定时器、移除事件监听

## tick

```
promise: Promise = tick()
```
返回一个Promise，在任何一个state状态发生变化时立即resolve
在Svelte中，当改变一个state状态时，不会立即更新DOM，而是会等到下一个微任务时更新，在等待期间会持续监听是否有其他state状态改变，然后在这个微任务中统一更新DOM，这样可以减少一些无用功，让浏览器更有效地批量处理这些事情

开发过程中可能会遇到这种问题：组件中的某个状态更新了，但 DOM 没有更新

这时就可以使用 tick 函数，它会返回一个 Promise，当组件的状态更新之后，会触发这个 Promise 的 resolves

是不是和vue的nextTick一样？



虽然在组件初始化期间调用生命周期函数很重要，但是从何处调用它们都无关紧要。

只要对应的生命周期函数可以在组件被初始化的时候执行到即可
```
import { onDestroy } from 'svelte';

export function onInterval(callback, milliseconds) {
  const interval = setInterval(callback, milliseconds);

  onDestroy(() => clearInterval(interval));
}

```
```
<script>
  // onDestory方法并没有被定义在组件中，而是被定义在了工具文件中
  import { onInterval } from './utils.js';

  let seconds = 0;
  onInterval(() => seconds += 1, 1000);
</script>

<p>
  The page has been open for
  {seconds} {seconds === 1 ? 'second' : 'seconds'}
</p>

```